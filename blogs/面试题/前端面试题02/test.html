<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue TypeScript React 微信小程序 webpack 面试题 | 干饭选手</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="干饭选手">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.e853742c.css" as="style"><link rel="preload" href="/assets/js/app.31276dfc.js" as="script"><link rel="preload" href="/assets/js/3.a0fff070.js" as="script"><link rel="preload" href="/assets/js/1.381cc6bf.js" as="script"><link rel="preload" href="/assets/js/4.36f6488d.js" as="script"><link rel="prefetch" href="/assets/js/10.804fa236.js"><link rel="prefetch" href="/assets/js/11.0af875b6.js"><link rel="prefetch" href="/assets/js/12.9c57e057.js"><link rel="prefetch" href="/assets/js/13.49d0a981.js"><link rel="prefetch" href="/assets/js/14.41dc5595.js"><link rel="prefetch" href="/assets/js/15.ec8d3b27.js"><link rel="prefetch" href="/assets/js/16.2fbf8f81.js"><link rel="prefetch" href="/assets/js/17.8914989f.js"><link rel="prefetch" href="/assets/js/18.35635778.js"><link rel="prefetch" href="/assets/js/19.52505f24.js"><link rel="prefetch" href="/assets/js/20.3979a42b.js"><link rel="prefetch" href="/assets/js/21.d079a370.js"><link rel="prefetch" href="/assets/js/22.a2aa5bd8.js"><link rel="prefetch" href="/assets/js/23.b80d0757.js"><link rel="prefetch" href="/assets/js/5.d7c9d2b5.js"><link rel="prefetch" href="/assets/js/6.726f8db6.js"><link rel="prefetch" href="/assets/js/7.6072e165.js"><link rel="prefetch" href="/assets/js/8.4bda5604.js"><link rel="prefetch" href="/assets/js/9.5858c340.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e853742c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>干饭选手</h3> <p class="description" data-v-59e6cb88>干饭选手</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>干饭选手</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="干饭选手" class="logo"> <span class="site-name">干饭选手</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      类别
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/category2/" class="nav-link"><i class="undefined"></i>
  category2
</a></li><li class="dropdown-item"><!----> <a href="/categories/nodejs/" class="nav-link"><i class="undefined"></i>
  nodejs
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试题/" class="nav-link"><i class="undefined"></i>
  面试题
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标记
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/theme-reco/" class="nav-link"><i class="undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://gitee.com/southraindow" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    干饭选手
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>12</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>3</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      类别
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/category2/" class="nav-link"><i class="undefined"></i>
  category2
</a></li><li class="dropdown-item"><!----> <a href="/categories/nodejs/" class="nav-link"><i class="undefined"></i>
  nodejs
</a></li><li class="dropdown-item"><!----> <a href="/categories/面试题/" class="nav-link"><i class="undefined"></i>
  面试题
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标记
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/theme-reco/" class="nav-link"><i class="undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://gitee.com/southraindow" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Vue TypeScript React 微信小程序 webpack 面试题</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>干饭选手</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Vue TypeScript React 微信小程序 webpack 面试题</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>干饭选手</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>8/15/2023</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>tag3</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="vue-篇"><a href="#vue-篇" class="header-anchor">#</a> Vue 篇</h1> <h3 id="_1-谈谈你对mvvm开发模式的理解"><a href="#_1-谈谈你对mvvm开发模式的理解" class="header-anchor">#</a> 1. 谈谈你对MVVM开发模式的理解？</h3> <blockquote><p>MVVM是一种简化用户界面的<strong>实践驱动编程方式</strong>。在当前主流的前后端分离的开发模式中，MVVM模式的优越性日益体现，相较于经典的MVC模式，其对于程序模块的封装很好地解决了前后端信息交互的冗余和繁琐</p> <p>MVVM分为Model、View、ViewModel三者。<br>
Model 代表数据模型，数据和业务逻辑都在Model层中定义；<br>
View 代表UI视图，负责数据的展示；<br>
ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；<br>
Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。<br>
这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。</p> <p>为什么使用MVVM：<code>低耦合</code>,<code>可复用</code>,<code>独立开发</code>,<code>可测试</code></p></blockquote> <h3 id="_2-v-if-和-v-show-有什么区别"><a href="#_2-v-if-和-v-show-有什么区别" class="header-anchor">#</a> 2. v-if 和 v-show 有什么区别？</h3> <blockquote><ul><li>手段
<ul><li>v-if是动态的向DOM树内添加或者删除DOM元素；</li> <li>v-show是通过设置DOM元素的display样式属性控制显隐；</li></ul></li> <li>编译
<ul><li>v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译;</li> <li>v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li></ul></li> <li>性能消耗：
<ul><li>v-if有更高的切换消耗；</li> <li>v-show有更高的初始渲染消耗</li></ul></li></ul></blockquote> <h3 id="_3-route-和-route和-route和router区别"><a href="#_3-route-和-route和-route和router区别" class="header-anchor">#</a> 3. route 和 route和 route和router区别</h3> <blockquote><ul><li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li> <li>$router 是“路由实例”想要导航到不同URL 对象包括了路由的跳转方法，钩子函数等。通过push、replace、go、back等方法，来实现页面间的跳转</li></ul></blockquote> <h3 id="_4-vue自定义指令"><a href="#_4-vue自定义指令" class="header-anchor">#</a> 4.vue自定义指令</h3> <blockquote><p>vue指令</p></blockquote> <blockquote><p><code>vue2</code></p> <p><code>局部注册</code>：directive选项</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token literal-property property">directives</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token string-property property">'focus'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>全局注册</code>：main.js</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> Vue<span class="token punctuation">.</span><span class="token function">directives</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
 	<span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>生命周期</code>：</p> <ul><li>bind：只调用一次，指令第一次绑到元素调用，用于初始化</li> <li>inserted：被绑定元素插入父节点时调用</li> <li>update：所在组件vnode更新调用</li> <li>componentUpdate：指令在组件的vnode及子组件的vnode全部更新完调用</li> <li>ubind：只调用一侧，指令解绑</li></ul></blockquote> <blockquote><p><code>vue3</code></p> <p><code>局部注册</code>：引入 import { Directive ， DirectiveBinding } from ‘vue’ 分别校验<code>vFocus</code>,<code>binding</code></p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-focus</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ color: 'red' }<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
 <span class="token keyword">const</span> vFocus <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token function">created</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;input type=&quot;text&quot; style=&quot;background-color: red;&quot;&gt; 'red'</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>全局注册</code>：main.js，app.vue如上引入</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
 <span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>
 <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>

 app<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">.</span>value<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&lt;input type=&quot;text&quot; style=&quot;background-color: red;&quot;&gt; 'red'</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>

 app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><code>生命周期</code>：</p> <ul><li>created 元素初始化的时候</li> <li>beforeMount 指令绑定到元素后调用 只调用一次</li> <li>mounted 元素插入父级dom调用</li> <li>beforeUpdate 元素被更新之前调用</li> <li>update 这个周期方法被移除 改用updated</li> <li>beforeUnmount 在元素被移除前调用</li> <li>unmounted 指令被移除后调用 只调用一次</li></ul></blockquote> <h3 id="_5-vue项目优化"><a href="#_5-vue项目优化" class="header-anchor">#</a> 5.vue项目优化</h3> <blockquote><ul><li>代码层面
<ul><li>长列表性能优化</li> <li>事件销毁， beforeDestroy生命周期函数内执行销毁逻辑。</li> <li>图片懒加载</li> <li>路由懒加载</li> <li>按需加载插件</li> <li>v-if，v-for避免同时使用</li> <li>v-if，v-show选择</li> <li>keep-alive组件缓存</li> <li>input防抖节流</li></ul></li> <li>基础的web技术优化
<ul><li>开启gzip压缩</li> <li>浏览器缓存</li> <li>CDN加速</li></ul></li> <li>webpack优化</li></ul></blockquote> <h3 id="_6-vue模板如何编译"><a href="#_6-vue模板如何编译" class="header-anchor">#</a> 6.vue模板如何编译</h3> <blockquote><p>Vue的模板编译就是将“HTML”模板编译成render函数的过程。这个过程大致可以分成三个阶段：</p> <ul><li>解析阶段：将“HTML”模板解析成AST语法树；</li> <li>核心 parseHTML( template ,{}) Vue定义了很多匹配HTML的正则表达式 ,parseHTML根据正则匹配</li> <li>parseHTML是解析模板字符串的“主线程”，它的第一个参数是要解析的模板字符串， 也就是单文件组件中最外层 所包裹的部分；第二个参数是一个选项对象，它会包含一些回调，以及一些配置项。</li> <li>选项对象：
<ul><li>start( tag, attrs, unary ) 匹配到开始标签时的回调，tag为当前标签的标签名，attrs为该标签上的属性列表，unary为当前标签是否为自闭合标签</li> <li>end() 匹配到结束标签时的回调</li> <li>chars(text) 匹配到文本节点的回调</li> <li>comment(text) 匹配到注释节点的回调，其处理逻辑跟文本的处理逻辑类似</li></ul></li> <li>优化阶段：从AST语法树中找出静态子树并进行标记（被标记的静态子树在虚拟dom比对时会被忽略，从而提高虚拟dom比对的性能）；
<ul><li>上面简单介绍过，优化阶段的工作就是标记静态子树，标记静态子树后主要有以下两个优点：
<ul><li>生成虚拟dom的过程中，如果发现一个节点是静态子树，除了首次渲染外不会生成新的子节点树，而是拷贝已存在的静态子树；</li> <li>比对虚拟dom的过程中，如果发现当前节点是静态子树，则直接跳过，不需要进行比对。</li></ul></li> <li>标记静态子树的过程分为两个步骤：
<ul><li>遍历AST语法树，找出所有的静态节点并打上标记（注：当前节点及其所有子节点都是静态节点，当前节点才会被打上静态节点的标记）</li> <li>遍历经过上面步骤后的树，找出静态根节点，并打上标记（注：静态根节点是指本身及所有子节点都是静态节点，但是父节点为动态节点的节点，找到了静态根节点也就找到了“静态子树”）</li></ul></li></ul></li> <li>代码生成阶段：通过AST生成代码字符串，并最终生成render函数。</li></ul></blockquote> <h3 id="_7-vue2响应式原理"><a href="#_7-vue2响应式原理" class="header-anchor">#</a> 7.vue2响应式原理</h3> <blockquote><p>vue 采用了几个核心部件 ： <code>Observer</code> ，<code>Dep</code>， <code>Watcher</code> ，<code>Scheduler</code></p> <ul><li>observer把一个普通的对象转换成响应式的对象</li> <li>observer 把对象的每个属性通过 object.defineProperty 转换为带有 getter 和 setter 的属性</li> <li>Dep 表示依赖, vue 会为响应式对象中的每一个属性，对象本身，数组本身创建一个 dep 实例，每个 dep 实例都可以做两件事情 :</li> <li>记录依赖：是谁在用我</li> <li>派发更新：我变了，我要通知那些用我的人</li> <li>watcher 在函数执行的过程中，如果发生了依赖记录，那么 dep 就会把这个全局变量记录下来，表示有一个 wathcer 用到了我这个属性。</li> <li>Scheduler 不会立即执行更新，通过nexttick异步更新</li></ul></blockquote> <h3 id="_8-vue3响应式原理"><a href="#_8-vue3响应式原理" class="header-anchor">#</a> 8.vue3响应式原理</h3> <blockquote><p><strong>通过Proxy（代理）：</strong> 拦截对象中任意属性的变化，包括：属性值的读写，属性的增加，属性的删除等。</p> <p><strong>通过Reffect（反射）：</strong> 对源对象的属性进行操作， Reflect不是一个函数对象，因此它是不可构造的。</p></blockquote> <h3 id="_9-刷新浏览器后-vuex的数据是否存在-如何解决"><a href="#_9-刷新浏览器后-vuex的数据是否存在-如何解决" class="header-anchor">#</a> 9.刷新浏览器后，Vuex的数据是否存在？如何解决？</h3> <blockquote><p><code>不存在</code></p> <p>原因： 因为 <code>store</code> 里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。</p> <p>我们有两种方法解决该问题：</p> <ol><li>使用 <code>vuex-along</code></li> <li>使用 <code>localStorage</code> 或者 <code>sessionStroage</code></li></ol></blockquote> <h3 id="_10-vue和react共同点-区别"><a href="#_10-vue和react共同点-区别" class="header-anchor">#</a> 10.vue和react共同点？区别</h3> <blockquote><p><code>共同点</code>:</p> <ul><li>数据驱动视图</li> <li>组件化</li> <li>都使用 <code>Virtual DOM</code></li></ul> <p><code>不同点</code>：</p> <ul><li>核心思想不同
<ul><li>vue定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。这就有了vue的主要特点：<code>灵活易用的渐进式框架，进行数据拦截/代理，它对侦测数据的变化更敏感、更精确</code>。</li> <li>react 定位就是提出 UI 开发的新思路 <code>React推崇函数式编程（纯组件），数据不可变以及单向数据流</code>,当然需要双向的地方也可以手动实现， 比如借助<code>onChange</code>和<code>setState</code>来实现。</li></ul></li> <li>组件写法
<ul><li>React推荐的做法是<code>JSX + inline style</code>, 也就是把 HTML 和 CSS 全都写进 JavaScript 中</li> <li>Vue 推荐的做法是 template 的单文件组件格式(<code>简单易懂，从传统前端转过来易于理解</code>),即 html,css,JS 写在同一个文件(vue也支持JSX写法)</li></ul></li> <li>diff算法</li> <li>响应式原理
<ul><li>vue2采用object.defineProperty ，vue3采用proxy，reflect</li> <li>React基于状态机，手动优化，数据不可变，需要<code>setState</code>驱动新的state替换老的state。</li></ul></li></ul></blockquote> <h3 id="_11-vue双向数据绑定原理"><a href="#_11-vue双向数据绑定原理" class="header-anchor">#</a> 11.vue双向数据绑定原理</h3> <blockquote><p><code>简易实现</code>：v-model分为两部分，通过v-bind绑定值，再通过v-on:input来通步修改值</p> <p><code>原理</code>：</p> <ul><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li> <li>通过dep来理清依赖关系，watcher在依赖中添加自身</li> <li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li> <li>待属性变动dep.notice()通知时，能调动watcher自身的update方法，并处罚compile回调渲染视图</li></ul></blockquote> <h3 id="_12-computed和watch区别"><a href="#_12-computed和watch区别" class="header-anchor">#</a> 12.computed和watch区别</h3> <blockquote><p>computed计算属性，watch监听属性</p> <ul><li>计算属性不在 data 中，它是基于data 或 props 中的数据通过计算得到的一个新值。watch 可以监听的数据来源：data，props，computed内的数据</li> <li>component中有get和set方法，会默认缓存计算结果。watch不支持缓存，支持异步， immediate监听属性立即执行一次，deep开启深度监听</li></ul></blockquote> <h3 id="_13-vuex"><a href="#_13-vuex" class="header-anchor">#</a> 13.Vuex</h3> <blockquote><p>Vuex是一种状态管理模式，存在的目的是共享可复用的组件状态。</p> <p><strong>主要包括以下几个模块：</strong></p> <ul><li>State =&gt; 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li> <li>Getter =&gt; 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li> <li>Mutation =&gt; 是唯一更改 store 中状态的方法，且必须是同步函数。</li> <li>Action =&gt; 像一个装饰器，包裹mutations，使之可以异步。用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li> <li>Module =&gt; 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul></blockquote> <h3 id="_14-vuex辅助函数"><a href="#_14-vuex辅助函数" class="header-anchor">#</a> 14.vuex辅助函数</h3> <blockquote><p><code>mapState</code>, <code>mapMutations</code>, <code>mapActions</code>, <code>mapGetters</code></p> <p>mapState和mapGetters:</p> <ul><li><p>两者都放在 computed中，以mapState举例</p> <p>import { mapState } from 'vuex'</p> <p>computed中
computed:{
...mapState(['data'])  //data是vuex存放的state中的属性，此时可使用
}</p></li></ul> <p>mapMutations， mapActions：</p> <ul><li>放在组件的<code>methods</code>属性中 。使用与上类似</li></ul></blockquote> <h3 id="_15-vuex模块化使用"><a href="#_15-vuex模块化使用" class="header-anchor">#</a> 15.vuex模块化使用</h3> <blockquote><p>当我们开发的项目比较大时，store中的数据就可能比较多，这时我们store中的数据就可能变得臃肿，为了解决这一问题，我们就需要将store模块化（module）</p> <p><code>前提</code>：创建两份js文件，含有属性与vuex写法相同，需要通过 <code>namespaced：true</code>开启命名空间store/index.js：在modules中引入文件</p> <p>使用：</p> <ul><li>访问state数据：
<ul><li>第一种方式：<code>this.$store.state.moduleA.sum</code></li> <li>第二种方式： <code>...mapState('moduleA',['sum','number'])</code></li></ul></li> <li>action提交mutation</li> <li>第一种方式：需要传参<code>this.$store.dispatch('moduleB/addZhang',{name:'小明',age:18})</code> ，无需传参<code>this.$store.dispatch('moduleB/addServer')</code></li> <li>第二种方式：<code>...mapActions('moduleB',['addZhang'])</code></li> <li>getters计算属性</li> <li>第一种方式： <code>this.$store.getters['moduleB/firstName']</code></li> <li>第二种方式：<code>...mapGetters('moduleB',['firstName'])</code></li></ul></blockquote> <h3 id="_16-vue中mixin"><a href="#_16-vue中mixin" class="header-anchor">#</a> 16.vue中mixin</h3> <blockquote><p>mixin(混入)： 提供了一种非常灵活的方式，来分发 <code>Vue</code> 组件中的可复用功能。</p> <p>本质其实就是一个<code>js</code>对象，它可以包含我们组件中任意功能选项，如<code>data</code>、<code>components</code>、<code>methods</code> 、<code>created</code>、<code>computed</code>等等</p> <p>我们只要将共用的功能以对象的方式传入 <code>mixins</code>选项中，当组件使用 <code>mixins</code>对象时所有<code>mixins</code>对象的选项都将被混入该组件本身的选项中来</p> <p>具体使用：</p> <ul><li><p>创建mixins.js文件</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> mixin <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是mixin中的'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">hellow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'你好'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> mixin
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li> <li><p>局部使用</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> mixin <span class="token keyword">from</span> <span class="token string">&quot;./mixins&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">mixins</span><span class="token operator">:</span> <span class="token punctuation">[</span>mixin<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hellow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//你好</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>全局使用main.js</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>
<span class="token keyword">import</span> mixins <span class="token keyword">from</span> <span class="token string">&quot;./mixins&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span>mixins<span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul></blockquote> <h3 id="_17-vue中给对象添加新属性时-界面不刷新怎么办"><a href="#_17-vue中给对象添加新属性时-界面不刷新怎么办" class="header-anchor">#</a> 17.Vue中给对象添加新属性时，界面不刷新怎么办?</h3> <blockquote><p>原因：vue2响应式采用object.defineProperty进行劫持，那个添加新属性时，新的属性不会具有get和set方法，不是一个响应式所以界面不刷新</p> <p>解决：Vue.set() 向响应式对象中添加一个<code>property</code>，并确保这个新 <code>property</code> 同样是响应式的</p> <p>vue3通过proxy劫持和reflect映射实现响应式，不会有这个问题</p></blockquote> <h3 id="_18-vue组件通讯方式"><a href="#_18-vue组件通讯方式" class="header-anchor">#</a> 18.vue组件通讯方式</h3> <blockquote><ul><li>通过 props 传递
<ul><li>props校验：name:{type:String,required:true,default:默认值} required是否必要</li></ul></li> <li>通过 $emit 触发自定义事件</li> <li>使用 ref</li> <li>EventBus</li> <li>Provide 与 Inject</li> <li>Vuex</li></ul></blockquote> <h3 id="_19-vue3setup的父传子怎么去写"><a href="#_19-vue3setup的父传子怎么去写" class="header-anchor">#</a> 19.vue3setup的父传子怎么去写？</h3> <blockquote><p>介绍三种方法：</p> <p>第一种：使用vue2写法通过props和$emit</p> <p>第二种：setup函数写法</p> <ul><li>setup(props,context)，通过props接收数据，通过context.emit(‘调用父组件方法’，传递参数)</li></ul> <p>第三种：script中setup</p> <ul><li><p>vue3自带defineProps，defineEmits</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> emits <span class="token operator">=</span> <span class="token function">defineEmits</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;changeNumber&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 也可以不赋值，取值通过{{num}}获取</span>
<span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">defineProps</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>
    <span class="token function-variable function">default</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> Array<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">changeNum</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">emits</span><span class="token punctuation">(</span><span class="token string">&quot;changeNumber&quot;</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//   console.log(11111111111);</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li></ul></blockquote> <h3 id="_20-setup可不可以直接写async和await"><a href="#_20-setup可不可以直接写async和await" class="header-anchor">#</a> 20.setup可不可以直接写async和await？</h3> <blockquote><p>可以</p> <p>setup 语法糖中可直接使用 await，不需要写 async ， setup 会自动变成 async setup</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
   <span class="token keyword">import</span> Api <span class="token keyword">from</span> <span class="token string">'../api/Api'</span>
   <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> Api<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
 <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></blockquote> <h3 id="_21-vue生命周期"><a href="#_21-vue生命周期" class="header-anchor">#</a> 21.vue生命周期</h3> <p><code>vue2</code></p> <p><img src="/assets/img/f9c692f63fb84948b79a5de9bd173ee0.bdd9f46b.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qlfjtF6I-1685109549653)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1685089235304.png)]"></p> <blockquote><p>beforeCreate – 首次访问data</p> <p>created – 首次访问this生命周期</p> <p>mounted – 页面展示</p></blockquote> <p><code>vue3</code></p> <p><img src="/assets/img/863ebacfed9644d49a0ea1182b5b165b.17a83758.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7tHeS6mz-1685109549654)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1685089301710.png)]"></p> <p><code>区别</code>：</p> <blockquote><ul><li>beforeCreate -&gt; setup() 开始创建组件之前，创建的是data和method</li> <li>created -&gt; setup()</li> <li>beforeMount -&gt; onBeforeMount 组件挂载到节点上之前执行的函数。</li> <li>mounted -&gt; onMounted 组件挂载完成后执行的函数</li> <li>beforeUpdate -&gt; onBeforeUpdate 组件更新之前执行的函数。</li> <li>updated -&gt; onUpdated 组件更新完成之后执行的函数。</li> <li>beforeDestroy -&gt; onBeforeUnmount 组件挂载到节点上之前执行的函数。</li> <li>destroyed -&gt; onUnmounted 组件卸载之前执行的函数。dszhuoyi</li> <li>activated -&gt; onActivated 组件卸载完成后执行的函数</li> <li>deactivated -&gt; onDeactivated</li></ul></blockquote> <h3 id="_22-说说-vue-中-css-scoped-的原理"><a href="#_22-说说-vue-中-css-scoped-的原理" class="header-anchor">#</a> 22.说说 Vue 中 CSS scoped 的原理</h3> <blockquote><p>添加scoped标签后会给组件中所有标签元素，添加一个唯一标识，这个唯一标识就是自定义属性，data-v-xxxxxxxx这样的字眼，同时对应的样式选择器也会添加这个唯一的属性选择器</p></blockquote> <h3 id="_23-nexttick原理"><a href="#_23-nexttick原理" class="header-anchor">#</a> 23.$nextTick原理</h3> <blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p></blockquote> <p><a href="https://blog.csdn.net/weixin_44273311/article/details/114318630" target="_blank" rel="noopener noreferrer">nextTick原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_24-data是函数不是对象"><a href="#_24-data是函数不是对象" class="header-anchor">#</a> 24.data是函数不是对象</h3> <blockquote><p>vue是一个单页面应用最终所有的实例都会挂载到app.vue文件，如果data是一个对象那么会导致数据污染。通过函数返回对象的方式，利用函数作用域的限制避免数据污染</p></blockquote> <h3 id="_25-路由守卫"><a href="#_25-路由守卫" class="header-anchor">#</a> 25.路由守卫</h3> <blockquote><p>vue路由守卫分为三种：全局路由守卫，独享路由守卫,组件路由守卫</p> <p>to： 进入到哪个路由去</p> <p>from： 来自哪个路由</p> <p>next：是否跳转</p> <ul><li>全局守卫： router.beforeEach((to,from,next)=&gt;{})</li> <li>独享路由守卫： beforeEnter:(to,from,next)=&gt;{}</li> <li>组件路由守卫： beforeRouteEnter:(to,from,next)=&gt;{}, beforeRouteUpdate , beforeRouteLeave</li></ul></blockquote> <h3 id="_26-vue设置全局变量"><a href="#_26-vue设置全局变量" class="header-anchor">#</a> 26.vue设置全局变量</h3> <blockquote><p>方法一：</p> <ul><li><p><code>vue2.x</code>挂载全局是使用 <code>Vue.prototype.$xxxx=xxx</code> 的形式来挂载，然后通过 <code>this.$xxx</code>来获取挂载到全局的变量或者方法。</p></li> <li><p><code>Vue 3</code> 中，使用 <code>config.globalProperties</code> 、app.config.globalProperties.$data = ‘111’</p> <p>const {proxy} = getCurrentInstance()
console.log(proxy.$data)</p></li></ul> <p>方法二：</p> <ul><li>provide/inject</li></ul></blockquote> <h3 id="_27-vue中keep-alive"><a href="#_27-vue中keep-alive" class="header-anchor">#</a> 27.vue中keep-alive</h3> <blockquote><p>属性：<code>include</code>和<code>exclude</code></p> <p>语法：</p> <div class="language- extra-class"><pre><code>// 指定home组件和about组件被缓存
&lt;keep-alive include=&quot;home,about&quot; &gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;

// 除了home组件和about组件别的都缓存
&lt;keep-alive exclude=&quot;home,about&quot; &gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre></div><p>钩子函数：</p> <ul><li><code>activated</code> 当组件被激活（使用）的时候触发 可以简单理解为进入这个页面的时候触发</li> <li><code>deactivated</code> 当组件不被使用（inactive状态）的时候触发 可以简单理解为离开这个页面的时候触发</li></ul> <p>进入开启缓存的组件</p> <div class="language- extra-class"><pre><code>初始进入和离开 created ---&gt; mounted ---&gt; activated --&gt; deactivated
后续进入和离开 activated --&gt; deactivated
</code></pre></div></blockquote> <h3 id="_28-vue插槽"><a href="#_28-vue插槽" class="header-anchor">#</a> 28.vue插槽</h3> <blockquote><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p> <p>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</p> <p>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</p> <p>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</p> <p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm. s l o t 中，默认插槽为 v m . slot中，默认插槽为vm. slot中，默认插槽为vm.slot.default，具名插槽为vm. s l o t . x x x ， x x x 为插槽名，当组件执行渲染函数时候，遇到 s l o t 标签，使用 slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用 slot.xxx，xxx为插槽名，当组件执行渲染函数时候，遇到slot标签，使用slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p></blockquote> <h3 id="_29-vue2和vue3区别"><a href="#_29-vue2和vue3区别" class="header-anchor">#</a> 29.vue2和vue3区别</h3> <blockquote><p><strong>双向绑定更新</strong></p> <p>vue2 的双向数据绑定是利?ES5 的?个 API ，Object.defineProperty()对数据进?劫持 结合 发布订阅模式的?式来实现的。</p> <p>vue3 中使?了 ES6 的 ProxyAPI 对数据代理，通过 reactive() 函数给每?个对象都包?层 Proxy，通过 Proxy 监听属性的变化，从? 实现对数据的监控。</p> <p>这?是相?于vue2版本，使?proxy的优势如下</p> <p>1.defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</p> <p>2.可以监听数组，不?再去单独的对数组做特异性操作,通过Proxy可以直接拦截所有对象类型数据的操作，完美?持对数组的监听。</p> <p><strong>获取props</strong></p> <p>vue2在script代码块可以直接获取props，vue3通过setup指令传递</p> <p><strong>API不同</strong></p> <p>Vue2使?的是选项类型API（Options API），Vue3使?的是合成型API（Composition API）</p> <p><strong>建立数据data</strong></p> <p>vue2是把数据放入data中，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造得时候触发。</p> <p><strong>生命周期不同</strong></p> <p>vue2 -------- vue3</p> <p>beforeCreate -&gt; setup() 开始创建组件之前，创建的是data和method</p> <p>created -&gt; setup()</p> <p>beforeMount -&gt; onBeforeMount 组件挂载到节点上之前执行的函数。</p> <p>mounted -&gt; onMounted 组件挂载完成后执行的函数</p> <p>beforeUpdate -&gt; onBeforeUpdate 组件更新之前执行的函数。</p> <p>updated -&gt; onUpdated 组件更新完成之后执行的函数。</p> <p>beforeDestroy -&gt; onBeforeUnmount 组件挂载到节点上之前执行的函数。</p> <p>destroyed -&gt; onUnmounted 组件卸载之前执行的函数。dszhuoyi</p> <p>activated -&gt; onActivated 组件卸载完成后执行的函数</p> <p>deactivated -&gt; onDeactivated</p> <p><strong>是否支持碎片</strong>：vue2.0 只允许有一个根标签，vue3.0支持碎片化，可以拥有多个根节点</p> <p><strong>main.js文件不同</strong>：vue2中我们可以使用pototype(原型)的形式去进行操作，引入的是构造函数 vue3中需要使用结构的形式进行操作，引入的是工厂函数</p> <p><strong>diff算法不同</strong></p> <p><strong>更好的支持ts</strong></p></blockquote> <h3 id="_30-vue3-0-所采用的-composition-api-组合式-与-vue2-x-使用的-options-api-选项式-有什么不同"><a href="#_30-vue3-0-所采用的-composition-api-组合式-与-vue2-x-使用的-options-api-选项式-有什么不同" class="header-anchor">#</a> 30.Vue3.0 所采用的 Composition Api (组合式)与 Vue2.x 使用的 Options Api(选项式) 有什么不同？</h3> <blockquote><ul><li>options Api 当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解 。composition Api它将功能定义在一起，利于查找和理解</li> <li><code>Composition API</code> 对 <code>tree-shaking</code> 友好，代码也更容易压缩</li> <li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li> <li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li></ul></blockquote> <h3 id="_31-vue3中hook"><a href="#_31-vue3中hook" class="header-anchor">#</a> 31.vue3中hook</h3> <blockquote><p>本质是一个函数，把setup函数中使用的Composition API（组合式api）进行了封装，类似于vue2中的mixin</p> <p>自定义hook优势：复用代码，让setup中的逻辑更清楚易懂</p></blockquote> <h3 id="_32-vue组件和插件的区别"><a href="#_32-vue组件和插件的区别" class="header-anchor">#</a> 32.vue组件和插件的区别</h3> <blockquote><p><code>组件</code>： Vue 组件是一个可复用的 Vue 实例，可以带有自己的状态和方法。组件可以包含其他组件，从而形成一个复杂的 UI 列表。</p> <p>优点</p> <ul><li>可以将代码封装成一个可复用的组件，提高开发效率。</li> <li>组件具有良好的可维护性，易于修改和更新。</li></ul> <p>缺点</p> <ul><li>组件的功能和作用比较独立，不太适用于全局功能的扩展。</li> <li>组件的管理和组织需要一定的规范，否则可能会导致混乱和不易维护。</li></ul> <p><code>插件</code>： Vue 插件可以扩展 Vue 的全局功能，在应用程序中可以重复使用。常见的插件如 <code>vue-router</code>、<code>vuex</code>、<code>axios</code> 等。</p> <p>优点</p> <ul><li>插件可以方便地扩展 Vue 的全局功能。</li> <li>插件可以使代码重复利用，提高开发效率。</li> <li>开源社区中已经有大量的插件可以用于解决常见的问题。</li></ul> <p>缺点</p> <ul><li>插件具有一定的复杂性，需要更多的学习成本。</li> <li>插件功能可能比较复杂，可能会导致性能下降。</li></ul></blockquote> <h3 id="_33-vue修饰符"><a href="#_33-vue修饰符" class="header-anchor">#</a> 33.vue修饰符</h3> <blockquote><p>在<code>Vue</code>中，修饰符处理了许多<code>DOM</code>事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理</p> <ul><li>表单修饰符
<ul><li>.lazy 懒加载，光标离开标签时，才赋值给value</li> <li>.trim 过滤首位空格</li> <li>.number 限制输入类型为数字或转为数字</li></ul></li> <li>事件修饰符
<ul><li>.stop 阻止事件冒泡</li> <li>.prevent 组织事件默认行为</li> <li>.once 事件只触发一次</li> <li>.capture 开启事件捕获</li> <li>.self 事件只在自身触发</li></ul></li> <li>鼠标按键修饰符
<ul><li>left 左键点击</li> <li>right 右键点击</li> <li>middle 中键点击</li></ul></li> <li>键值修饰符
<ul><li>普通键（enter、tab、delete、space、esc、up…）</li> <li>系统修饰键（ctrl、alt、meta、shift…）</li></ul></li> <li>v-bind修饰符
<ul><li>.async 对props进行双向绑定</li> <li>.prop 设置自定义标签属性，避免暴露数据，防止污染html结构</li> <li>.camel 将命名为驼峰命名法</li></ul></li></ul></blockquote> <h3 id="_34-vue路由中-history和hash两种模式有什么区别"><a href="#_34-vue路由中-history和hash两种模式有什么区别" class="header-anchor">#</a> 34.Vue路由中，history和hash两种模式有什么区别？</h3> <blockquote><p><code>hash</code>: hash 模式是一种把前端路由的路径用井号 <code>#</code> 拼接在真实 URL 后面的模式。当井号 <code>#</code> 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 <code>hashchange</code> 事件。</p> <ul><li><strong>优点</strong>：浏览器兼容性较好，连 IE8 都支持</li> <li><strong>缺点</strong>：路径在井号 <code>#</code> 的后面，比较丑</li></ul> <p><code>history</code>: history API 是 H5 提供的新特性，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求</p> <ul><li><strong>优点</strong>：路径比较正规，没有井号 <code>#</code></li> <li><strong>缺点</strong>：兼容性不如 hash，且需要服务端支持，否则一刷新页面就404了</li></ul></blockquote> <h3 id="_35-params和query区别"><a href="#_35-params和query区别" class="header-anchor">#</a> 35.params和query区别</h3> <blockquote><p><code>params</code> 和 <code>query</code> 都是用于传递参数的，但它们的传参方式和使用场景是不同的。</p> <p><code>params</code> 通过路由路径传递参数，在路由配置中使用 <code>:paramName</code> 的形式进行声明</p> <div class="language- extra-class"><pre><code>const router = new VueRouter({
  routes: [
    {
      path: '/user/:id',
      component: User,
    },
  ],
})
</code></pre></div><p><code>query</code> 通过 URL 查询字符串（即问号后面的部分）传递参数，在路由地址后面使用 <code>?</code> 连接多个参数键值对</p> <p><strong>不需要在router中配置</strong> <code>/search?q=vue</code> 会自动匹配到search组件</p> <p>区别：</p> <ul><li><code>params</code> 适合用于必须存在的参数传递，例如用户详情页或文章详情页的访问。</li> <li><code>query</code> 适合用于可选的参数传递，例如搜索功能中关键词的传递。</li></ul></blockquote> <h3 id="_36-vue2中assets和vue3中public区别"><a href="#_36-vue2中assets和vue3中public区别" class="header-anchor">#</a> 36.vue2中assets和vue3中public区别 ？</h3> <blockquote><p>在 Vue 2 中，<code>assets</code> 目录是默认存在的，可以直接在项目的根目录下创建，它通常用来存放组件需要的图片、样式等静态资源文件。这些文件会被打包到 JavaScript 文件中，在代码中使用相对路径引用。</p> <p>在 Vue 3 中，可以通过配置 <code>vue.config.js</code> 文件来设置 <code>public</code> 目录，它的作用与 <code>assets</code> 目录类似，用来存放静态资源文件。但是，与 Vue 2 不同的是，<code>public</code> 目录下的文件不会被打包，而是会直接复制到输出目录下</p></blockquote> <h3 id="_37-单页应用如何提高加载速度"><a href="#_37-单页应用如何提高加载速度" class="header-anchor">#</a> 37.单页应用如何提高加载速度？</h3> <blockquote><ul><li>使用代码分割：将代码拆分成小块并按需加载（懒加载），以避免不必要的网络请求和减少加载时间。</li> <li>缓存资源：利用浏览器缓存来存储重复使用的文件，例如 CSS 和 JS 文件、图片等。</li> <li>预加载关键资源：在首次渲染之前，先提前加载关键资源，例如首页所需的 JS、CSS 或数据，以保证关键内容的快速呈现。</li> <li>使用合适的图片格式：选择合适的图片格式（例如 JPEG、PNG、WebP 等），并根据需要进行压缩以减少文件大小。对于一些小图标，可以使用 <code>iconfont</code> 等字体文件来代替。</li> <li>启用 Gzip 压缩：使用服务器端的 Gzip 压缩算法对文件进行压缩，以减少传输时间和带宽消耗。</li> <li>使用 CDN：使用内容分发网络（CDN）来缓存和传递文件，以提高文件的下载速度和可靠性。</li> <li>优化 API 请求：尽可能地减少 API 调用的数量，并使用缓存和延迟加载等技术来优化 API 请求的效率。</li> <li>使用服务器端渲染：使用服务器端渲染（SSR）来生成 HTML，以减少客户端渲染所需的时间和资源。但需要注意，SSR 也可能增加了服务器的负担并使网站更复杂。</li></ul></blockquote> <h3 id="_38-vue父组件调用子组件的方法"><a href="#_38-vue父组件调用子组件的方法" class="header-anchor">#</a> 38.Vue父组件调用子组件的方法</h3> <blockquote><p>vue中如果父组件想调用子组件的方法，可以在子组件中加上ref，然后通过this.$refs.ref.method调用</p> <div class="language- extra-class"><pre><code>&lt;child ref=&quot;child&quot;&gt;&lt;/child&gt;
调用：this.$refs.child.子组件方法
</code></pre></div></blockquote> <h3 id="_39-vue3中dom获取-ref在组件上使用"><a href="#_39-vue3中dom获取-ref在组件上使用" class="header-anchor">#</a> 39.vue3中dom获取，ref在组件上使用</h3> <blockquote><div class="language- extra-class"><pre><code>&lt;template&gt;
  &lt;div class=&quot;ref&quot;&gt;
    &lt;h3&gt;ref使用：&lt;/h3&gt;
    &lt;input type=&quot;text&quot; ref=&quot;input&quot; /&gt; //  ref=&quot;input&quot; 需要和 const input = ref(null); 相对应
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { reactive, ref, createApp, onMounted } from &quot;vue&quot;;

let state = reactive({ text: &quot;信息按钮&quot; });
// 同名的 input来进行获取节点
const input = ref(null);
onMounted(() =&gt; {
  if (input.value) {
    input.value.focus();
  }
});
&lt;/script&gt;
&lt;style scoped&gt;&lt;/style&gt;
</code></pre></div></blockquote> <h3 id="_40-渐进式框架理解"><a href="#_40-渐进式框架理解" class="header-anchor">#</a> 40.渐进式框架理解</h3> <blockquote><p>渐进式： 可以理解为没有多做职责之外的事</p> <p>个人理解：主张最少的，一开始仅基于基础框架构建，随着需求不断扩充</p></blockquote> <h3 id="_41-页面初始化闪烁"><a href="#_41-页面初始化闪烁" class="header-anchor">#</a> 41.页面初始化闪烁</h3> <blockquote><p>产生原因：当网速较慢，<code>vue.js</code>文件还没有加载完时，在页面上会显示的字样，知道vue创建实例，编译模板时，dom才会被替换，所以这个过程屏幕是闪动的。</p> <p>所以解决这个问题，需要在style样式中设置【v-cloak】{display：none}。在一般情况下，v-clock是一个解决初始化慢导致页面闪动的最佳实践，对于简单的项目很实用。</p> <p>但是在具有工程化的项目里，比如使用了webpack和vue-router的项目中，html结构只是一个空的div元素，剩余的内容都是由路由去挂载不同的组件完成的，所以不需要v-cloak。</p></blockquote> <h3 id="_42-vue属性名和method名称一致出现什么问题"><a href="#_42-vue属性名和method名称一致出现什么问题" class="header-anchor">#</a> 42.vue属性名和method名称一致出现什么问题</h3> <blockquote><p>vue2中， 这个<code>属性</code>会覆<code>盖掉 methods</code> 中的方法。也就是说，这个方法将无法被正确调用。</p> <p>vue3中，报错</p></blockquote> <h3 id="_43-class和style如何动态绑定"><a href="#_43-class和style如何动态绑定" class="header-anchor">#</a> 43.class和style如何动态绑定</h3> <blockquote><p>class 与 style 动态绑定一般通过对象或者数组来实现</p> <p><strong>对象写法：适用于要绑定的样式名字样式确定，但动态决定用不用。</strong></p> <p><strong>数组写法：适用于要绑定的样式名字样式不确定。</strong></p> <div class="language- extra-class"><pre><code>&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt; //对象写法
&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; //数组写法
</code></pre></div></blockquote> <h3 id="_44-vue遇到的坑"><a href="#_44-vue遇到的坑" class="header-anchor">#</a> 44.vue遇到的坑</h3> <blockquote><ul><li>data必须是一个函数，而不是一个对象</li> <li>vue管理的函数不要写成箭头函数</li> <li>添加属性页面不刷新</li> <li>子路由path不需要添加**/**,path=‘new’</li></ul></blockquote> <h3 id="_45-v-if和v-for-优先级"><a href="#_45-v-if和v-for-优先级" class="header-anchor">#</a> 45.v-if和v-for 优先级</h3> <blockquote><p>实践中不管是vue2或者vue3都不应该把v-if和v-for放在一起使用。</p> <p>在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时， v-for 会优先作用。</p> <p>在 vue 3.x 中， v-if 总是优先于 v-for 生效。</p> <p>vue2中v-for的优先级是高于v-if的，放在一起，会先执行循环在判断条件，并且如果值渲染列表中一小部分元素，也得再每次重渲染的时候遍历整个列表，比较浪费资源。</p> <p>vue3中v-if的优先级是高于v-for的，所以v-if执行时，它调用相应的变量如果不存在，就会导致异常</p></blockquote> <h3 id="_46-vue核心原理"><a href="#_46-vue核心原理" class="header-anchor">#</a> 46.vue核心原理</h3> <blockquote><p>数据驱动，组建系统</p></blockquote> <h3 id="_47-vue自带动画组件-transition"><a href="#_47-vue自带动画组件-transition" class="header-anchor">#</a> 47.vue自带动画组件， transition</h3> <blockquote><p>组件是 Vue 提供的用于包裹需要动画效果的元素组件。使用组件可以方便地实现元素的进入和离开动画效果。</p> <div class="language- extra-class"><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;visible = !visible&quot;&gt;Toggle&lt;/button&gt;
    &lt;transition name=&quot;fade&quot;&gt;
      &lt;p v-if=&quot;visible&quot;&gt;Hello, World!&lt;/p&gt;
    &lt;/transition&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      visible: false
    }
  },
}
&lt;/script&gt;
 &lt;style&gt;
.fade-enter-active, .fade-leave-active {
  transition: opacity .5s;
}
.fade-enter, .fade-leave-to {
  opacity: 0;
}
</code></pre></div></blockquote> <h3 id="_48-vue-loader工作原理"><a href="#_48-vue-loader工作原理" class="header-anchor">#</a> 48.vue-loader工作原理</h3> <blockquote><ol><li>将一个 <strong>.vue 文件</strong> 切割成 <strong>template</strong>、<strong>script</strong>、<strong>styles</strong> 三个部分。</li> <li><strong>template 部分</strong> 通过 <strong>compile</strong> 生成 <strong>render</strong>、 <strong>staticRenderFns</strong>。</li> <li>获取 <strong>script 部分</strong> 返回的配置项对象 <strong>scriptExports</strong>。</li> <li><strong>styles 部分</strong>，会通过 <strong>css-loader</strong>、<strong>vue-style-loader</strong>， 添加到 <strong>head</strong> 中， 或者通过 <strong>css-loader</strong>、<strong>MiniCssExtractPlugin</strong> 提取到一个 <strong>公共的css文件</strong> 中。</li> <li>使用 <strong>vue-loader</strong> 提供的 <strong>normalizeComponent</strong> 方法， <strong>合并 scriptExports、render、staticRenderFns</strong>， 返回 <strong>构建vue组件需要的配置项对象 - options</strong>， 即 <strong>{data, props, methods, render, staticRenderFns…}</strong>。</li></ol></blockquote> <h3 id="_49-vue的diff算法"><a href="#_49-vue的diff算法" class="header-anchor">#</a> 49.vue的diff算法</h3> <blockquote><p><code>diff</code>整体策略为：深度优先，同层比较</p> <ul><li><p>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</p></li> <li><p>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</p></li> <li><p>patchVnode</p> <p>做了以下操作：</p> <ul><li>找到对应的真实<code>dom</code>，称为<code>el</code></li> <li>如果都有都有文本节点且不相等，将<code>el</code>文本节点设置为<code>Vnode</code>的文本节点</li> <li>如果<code>oldVnode</code>有子节点而<code>VNode</code>没有，则删除<code>el</code>子节点</li> <li>如果<code>oldVnode</code>没有子节点而<code>VNode</code>有，则将<code>VNode</code>的子节点真实化后添加到<code>el</code></li> <li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点</li></ul></li> <li><p>updateChildren</p> <p>主要做了以下操作：</p> <ul><li>设置新旧<code>VNode</code>的头尾指针</li> <li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用<code>patchVnode</code>进行<code>patch</code>重复流程、调用<code>createElem</code>创建一个新节点，从哈希表寻找 <code>key</code>一致的<code>VNode</code> 节点再分情况操作</li></ul></li></ul></blockquote> <h3 id="_50-vue和jquery区别"><a href="#_50-vue和jquery区别" class="header-anchor">#</a> 50.vue和jquery区别</h3> <blockquote><p><code>设计理念</code></p> <p>Vue.js 是一个现代化的JavaScript框架，专注于构建大型的、可维护的Web应用程序。Vue.js 的核心是组件化，它提供了一种将页面分解成独立、可重用的组件的方式，并且能够非常容易地管理这些组件之间的依赖关系。同时，Vue.js 还内置了状态管理、路由、构建工具等功能，使得构建复杂的 Web 应用程序更加容易。</p> <p>而 jQuery 则是一个早期的 JavaScript 库，主要关注的是 DOM 操作和处理事件。它的设计理念是将 JavaScript 代码尽可能地简单化，使得使用者可以很容易地完成一些常见的操作（如选择元素、修改样式、处理事件等）。在 jQuery 中，通过链式调用和函数式变成的设计，可以使得代码变得非常简洁易读。</p> <p><code>用途</code></p> <p>Vue.js 主要用于构建大型的、复杂的 Web 应用程序，它提供了诸如组件化、状态管理、路由等功能，非常适合构建单页面应用（SPA）。</p> <p>而 jQuery 则更多地用于简化 DOM 操作和事件处理，它适用于编写小型的 Web 应用程序或较为简单的交互效果。同时，由于 jQuery 在浏览器兼容性、性能等方面的优势，它也被广泛应用于一些成熟的网站和CMS系统中。</p></blockquote> <h3 id="_51-说说你对-spa-单页面的理解-它的优缺点分别是什么"><a href="#_51-说说你对-spa-单页面的理解-它的优缺点分别是什么" class="header-anchor">#</a> 51.说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3> <blockquote><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p> <ul><li>优点：<br>
用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；<br>
基于上面一点，SPA 相对对服务器压力小；<br>
前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li> <li>缺点：<br>
初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统加载，部分页面按需加载；<br>
前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；<br>
SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul></blockquote> <h3 id="_52-怎样理解-vue-的单向数据流"><a href="#_52-怎样理解-vue-的单向数据流" class="header-anchor">#</a> 52. 怎样理解 Vue 的单向数据流？</h3> <blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。<br>
这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。<br>
额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>
这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>
子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p></blockquote> <h3 id="_53-父组件可以监听到子组件的生命周期吗"><a href="#_53-父组件可以监听到子组件的生命周期吗" class="header-anchor">#</a> 53. 父组件可以监听到子组件的生命周期吗？</h3> <blockquote><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p></blockquote> <div class="language- extra-class"><pre><code>// Parent.vue
&lt;Child @mounted=&quot;doSomething&quot;/&gt;

// Child.vue
mounted() {
  this.$emit(&quot;mounted&quot;);
}
</code></pre></div><blockquote><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p></blockquote> <div class="language- extra-class"><pre><code>//  Parent.vue
&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},

//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    

// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...
</code></pre></div><blockquote><p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p></blockquote> <h3 id="_54-vue3-0-性能提升主要是通过哪几方面体现的"><a href="#_54-vue3-0-性能提升主要是通过哪几方面体现的" class="header-anchor">#</a> 54.Vue3.0 性能提升主要是通过哪几方面体现的</h3> <blockquote><ul><li>diff算法优化</li> <li>静态提升： <code>Vue3</code>中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</li> <li>移除一些不常用的API，再重要的是<code>Tree shanking</code></li> <li>响应式系统</li></ul></blockquote> <h3 id="_55-什么是-mvvm-比之-mvc-有什么区别-什么又是-mvp"><a href="#_55-什么是-mvvm-比之-mvc-有什么区别-什么又是-mvp" class="header-anchor">#</a> 55.什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h3> <blockquote><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。 用户与页面产生交互时Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p> <p>MVVM 模式中的 VM，指的是 ViewModel， 它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。</p> <p>MVP 模式 ，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新</p></blockquote> <h3 id="_56-vue中hook和react中hook区别"><a href="#_56-vue中hook和react中hook区别" class="header-anchor">#</a> 56.vue中hook和react中hook区别</h3> <blockquote><p>在React中，hook是一种函数，它可以让你在函数组件中添加state、effect等功能。 React 中的hook有useState、useEffect、useContext等。使用hook可以避免使用类组件时可能会出现的繁琐的生命周期方法、this等问题。</p> <p>在Vue中，hook被称为生命周期钩子函数，它们是在组件实例化过程中自动调用的回调函数。 Vue中的生命周期钩子函数包括beforeCreate、created、beforeMount、mounted等。它们可以用于控制组件的生命周期，以及在组件生命周期特定阶段执行特定的操作。</p></blockquote> <h3 id="_57-redux和vuex的区别"><a href="#_57-redux和vuex的区别" class="header-anchor">#</a> 57.Redux和Vuex的区别</h3> <blockquote><p>redux是一个范用的js库，vuex是专门服务vue的</p> <p>相同点：</p> <ol><li>state共享数据</li> <li>流程一致：定义全局state，触发，修改state</li> <li>原理相似，通过全局注入store。</li></ol> <p>不同点:</p> <ol><li>Vuex定义了state，getter、mutation、action，module五个对象；redux定义了state、reducer、action;</li> <li>Vuex触发方式有两种commit同步和dispatch异步；redux同步和异步都使用dispatch;</li> <li>Vuex中action有较为复杂的异步ajax请求；redux中action中可简单可复杂，简单就直接发送数据对象（{type:xxx, your-data}）,复杂需要调用异步ajax（依赖redux-thunk插件）。</li> <li>Redux使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改；</li> <li>Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过getter/setter来比较的。</li></ol></blockquote> <h3 id="_58-vue服务端渲染-ssr-解决了哪些问题"><a href="#_58-vue服务端渲染-ssr-解决了哪些问题" class="header-anchor">#</a> 58.vue服务端渲染(SSR),解决了哪些问题？</h3> <blockquote><p>Vue服务端渲染（SSR）通过在服务器上预先生成Vue组件的HTML字符串，并将其发送到客户端，以实现更快的页面加载速度、更好的搜索引擎优化和更好的用户体验。服务端渲染解决了许多SPA（Single Page Application）应用程序中存在的问题，例如：</p> <ol><li>SEO（搜索引擎优化）问题：由于传统的SPA应用程序是在浏览器中构建的，因此搜索引擎无法正确地索引它们的内容。使用Vue SSR，可以在服务器上呈现HTML字符串并向搜索引擎提供更好的友好的页面。</li> <li>性能问题：SPA应用程序需要大量的JavaScript代码来初始化应用程序并交互。这可能导致页面加载时间缓慢，用户体验较差。使用Vue SSR，可以在浏览器中更快地呈现初始HTML的完整标志，并在其中嵌入必要的JavaScript。这样可以加快页面加载速度，并提高用户体验。</li> <li>首屏渲染问题：传统的SPA应用程序在首次加载时可能会需要大量时间才能呈现第一个屏幕，直到JavaScript代码完成下载并执行。使用Vue SSR，可以在服务器上呈现组件，并将其作为HTML字符串发送到客户端，从而实现快速呈现首屏的目标。</li></ol></blockquote> <h3 id="_59-vue-3-0中treeshaking特性是什么-并举例进行说明"><a href="#_59-vue-3-0中treeshaking特性是什么-并举例进行说明" class="header-anchor">#</a> 59.Vue 3.0中Treeshaking特性是什么，并举例进行说明？</h3> <blockquote><p><code>Tree shaking</code> 是一种通过清除多余代码方式来优化项目打包体积的技术</p> <p><code>Tree shaking</code>是基于<code>ES6</code>模板语法（<code>import</code>与<code>export</code>），主要是借助<code>ES6</code>模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p> <p><code>Tree shaking</code>无非就是做了两件事：</p> <ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li> <li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul> <p>作用：</p> <ul><li>减少程序体积（更小）</li> <li>减少程序执行时间（更快）</li> <li>便于将来对程序架构进行优化（更友好）</li></ul></blockquote> <h3 id="_60-虚拟-dom-的优缺点"><a href="#_60-虚拟-dom-的优缺点" class="header-anchor">#</a> 60. 虚拟 DOM 的优缺点？</h3> <blockquote><p>优点：</p> <ul><li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li> <li>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li> <li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul> <p>缺点:</p> <ul><li>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul></blockquote> <h3 id="_61-虚拟-dom-实现原理"><a href="#_61-虚拟-dom-实现原理" class="header-anchor">#</a> 61. 虚拟 DOM 实现原理？</h3> <blockquote><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p> <ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li> <li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li> <li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul></blockquote> <h3 id="_62-vue-中的-key-有什么作用"><a href="#_62-vue-中的-key-有什么作用" class="header-anchor">#</a> 62. Vue 中的 key 有什么作用？</h3> <blockquote><p><strong>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</strong><br>
Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。<br> <strong>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速!</strong></p> <ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</li> <li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</li></ul></blockquote> <div class="language- extra-class"><pre><code>function createKeyToOldIdx (children, beginIdx, endIdx) {
  let i, key
  const map = {}
  for (i = beginIdx; i &lt;= endIdx; ++i) {
    key = children[i].key
    if (isDef(key)) map[key] = i
  }
  return map
}
</code></pre></div><h3 id="_62-1-object-defineproperty怎么用-三个参数-有什么作用啊"><a href="#_62-1-object-defineproperty怎么用-三个参数-有什么作用啊" class="header-anchor">#</a> 62.1 Object.defineProperty怎么用， 三个参数？，有什么作用啊？</h3> <p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p> <div class="language- extra-class"><pre><code>     obj：需要定义属性的对象
     prop：需要定义的属性
     {}：要定义或修改的属性描述符。
	     value: &quot;18&quot;,         // 设置默认值 （与 get() 互斥）
	     enumerable: true,    //这一句控制属性可以枚举 enumerable 改为true 就可以参与遍历了   默认值false
	     writable: true,      // 该属性是否可写   默认值false （与 set() 互斥）
	     configurable: true,  // 该属性是否可被删除   默认值false
	      get // 当有人读取 prop 的时候  get函数就会调用,并且返回就是 sss 的值
	      set // 当有人修改 prop 的时候  set函数就会调用, 有个参数这个参数就是修改后的值
</code></pre></div><h3 id="_63-reactive与ref的区别"><a href="#_63-reactive与ref的区别" class="header-anchor">#</a> 63.reactive与ref的区别？</h3> <blockquote><p>从定义数据角度对比：</p> <ul><li><p>ref用来定义：基本类型数据</p></li> <li><p>reactive用来定义对象（或数组）类型数据</p></li></ul> <p>备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。</p> <p>从原理角度对比：</p> <ul><li>ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。</li> <li>reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。</li></ul> <p>从使用角度对比：</p> <ul><li>ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。</li> <li>reactive定义的数据：操作数据与读取数据：均不需要.value。</li></ul></blockquote> <h3 id="_64-v-on可以监听多个方法吗"><a href="#_64-v-on可以监听多个方法吗" class="header-anchor">#</a> 64.v-on可以监听多个方法吗？</h3> <p>可以一个元素绑定多个事件的两种写法</p> <div class="language- extra-class"><pre><code>&lt;a v-on='{click:DoSomething,mouseleave:MouseLeave}'&gt;doSomething&lt;/a&gt;
&lt;button @click=&quot;a(),b()&quot;&gt;点我ab&lt;/button&gt;
</code></pre></div><h3 id="_65-vue3中如何获取refs-dom对象的方式-vue2中如何使用"><a href="#_65-vue3中如何获取refs-dom对象的方式-vue2中如何使用" class="header-anchor">#</a> 65.vue3中如何获取refs，dom对象的方式？vue2中如何使用？</h3> <blockquote><p>vue3：</p> <p>(1) setup函数方法内，获取单个ref属性绑定的dom元素：先定义一个空的响应式数据ref定义的，你想获取哪个dom元素，在该元素上使用ref属性绑定该数据即可，通过ref.value即可获取到dom节点</p> <p>(2) 获取多个ref属性绑定的dom元素。使用ref绑定一个函数，在函数里把dom添加到数组里面</p></blockquote> <div class="language- extra-class"><pre><code>//vue2
&lt;h3 ref=&quot;myref&quot;&gt;myref&lt;/h3&gt;

//获取
this.$refs.myref
</code></pre></div><h3 id="_66-shallowreactive和shallowref的区别"><a href="#_66-shallowreactive和shallowref的区别" class="header-anchor">#</a> 66.shallowReactive和shallowRef的区别</h3> <blockquote><p><strong>(1)</strong> shallowReactive：只处理对象最外层的响应式（浅响应式）</p> <p><strong>(2)</strong> shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理。</p> <p>(3) 应用场景：</p> <p>① 如果有一个对象数据，结构比较深，但变化时候，只是外层属性变化，使用shallowReactive。</p> <p>② 如果有一个对象数据，后续功能不会修改改对象中的属性，而是生成新的对象来替换，使用shallowRef。</p></blockquote> <h3 id="_67-provide与inject如何使用"><a href="#_67-provide与inject如何使用" class="header-anchor">#</a> 67.provide与inject如何使用</h3> <blockquote><p>(1) 父子组件传参可以通过props和emit来实现，但是当组件的层次结构比较深时，props和emit就没什么作用了。vue为了解决这个提出了Provide / Inject;provider/inject：简单的来说就是在父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量</p> <p>(2) provide需要先引入，我们将需要传递给下级组件的变量通过provider（‘传输key’,变量）</p> <p>(3) Inject，下级组件通过变量方式接收，person= inject(‘传输key’)</p></blockquote> <h3 id="_68-toraw-与-markraw是什么作用"><a href="#_68-toraw-与-markraw是什么作用" class="header-anchor">#</a> 68.toRaw 与 markRaw是什么作用？</h3> <blockquote><p>(1) toRaw ：将一个由reactive生成的响应式对象转化为普通对象</p> <p>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新.</p> <p>(2) markRaw:标记一个对象，使其永远不会再成为响应式对象。</p> <p>应用场景：有些值不应被设置为响应式的，例如复杂的第三方类的库，当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能</p></blockquote> <h3 id="_69-readonly和shallowreadonly理解"><a href="#_69-readonly和shallowreadonly理解" class="header-anchor">#</a> 69.Readonly和shallowReadonly理解</h3> <blockquote><p>readonly：让一个响应式数据变为只读的（深只读），readonly是一个函数，他会接收一个响应式的数据</p> <p>shallowReadonly：让一个响应式数据变为只读的（浅只读），shallowReadonly只限制对象中的第一层数据（不能改动，如：salary），但是嵌套的深层次的value属性值 是可以更改的，我们点击更改按钮测试就能发现，被shallowReadonly包裹的对象的深层次值改变了。</p></blockquote> <h3 id="_70-toref和torefs区别"><a href="#_70-toref和torefs区别" class="header-anchor">#</a> 70.toref和torefs区别</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">toRef</span><span class="token template-punctuation string">`</span></span> 和 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">toRefs</span><span class="token template-punctuation string">`</span></span> 可以用来复制 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">reactive</span><span class="token template-punctuation string">`</span></span> 里面的属性然后转成 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">ref</span><span class="token template-punctuation string">`</span></span>，而且它既保留了响应式，也保留了<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">引用</span><span class="token template-punctuation string">`</span></span>
 
 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">toref(变量，属性)，torefs(整个变量)</span><span class="token template-punctuation string">`</span></span>
 
 区别：
 
 <span class="token operator">*</span>   在插值表达式中<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">:</span>
     <span class="token operator">*</span>   访问 toRefs 的值，需要带上 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">.value</span><span class="token template-punctuation string">`</span></span> 如果不带上，就会出现双引号 <span class="token punctuation">{</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>name<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span>
     <span class="token operator">*</span>   访问 toRef 的值，不需要带上 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">.value</span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">{</span><span class="token punctuation">{</span>user<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token punctuation">}</span>
 <span class="token operator">*</span>   转换属性：
     <span class="token operator">*</span>   toRef<span class="token operator">:</span> 复制 reactive 里的<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">单个</span><span class="token template-punctuation string">`</span></span>属性并转成 ref
     <span class="token operator">*</span>   toRefs<span class="token operator">:</span> 复制 reactive 里的<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">所有</span><span class="token template-punctuation string">`</span></span>属性并转成 ref
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_71-学习-eventbus"><a href="#_71-学习-eventbus" class="header-anchor">#</a> 71.学习 EventBus</h3> <p>首先，在你的项目中创建一个 <code>eventBus.js</code> 文件，并定义一个空的 EventBus 对象：</p> <div class="language- extra-class"><pre><code>import Vue from 'vue';
export const EventBus = new Vue();
</code></pre></div><p>发送事件</p> <div class="language- extra-class"><pre><code>import { EventBus } from './eventBus.js';

// 发送名为 'myEvent' 的事件
EventBus.$emit('myEvent', data);
</code></pre></div><p>接收事件</p> <div class="language- extra-class"><pre><code>import { EventBus } from './eventBus.js';

EventBus.$on('myEvent', (data)=&gt;{});
</code></pre></div><p>取消监听</p> <div class="language- extra-class"><pre><code>EventBus.$off('myEvent');
</code></pre></div><h3 id="_72-vue2过滤器-vue3取消"><a href="#_72-vue2过滤器-vue3取消" class="header-anchor">#</a> 72.vue2过滤器(vue3取消)</h3> <blockquote><p><code>filter</code> 过滤器是一种很常用的功能，它可以用于对数据进行格式化、排序、筛选等操作。在使用过程中，我们只需要在模板表达式中使用管道符 <code>|</code>，并将要使用的过滤器的名称作为参数传递进去即可。</p> <p><code>全局过滤器</code>：Vue.filter(‘过滤器名称’,function(){})</p> <p><code>局部过滤器</code>：filter选项</p></blockquote> <div class="language- extra-class"><pre><code>filters: {
    //filterName过滤器名，value是'|'之前的数据
    filterName(value) {
      if (!value) return '';
      return '你好'+value.toString()
    }
  }
</code></pre></div><h3 id="_73-vue可以通过计算属性监听计算属性吗"><a href="#_73-vue可以通过计算属性监听计算属性吗" class="header-anchor">#</a> 73. vue可以通过计算属性监听计算属性吗</h3> <blockquote><p>答案：<code>不可以</code></p> <p>计算属性依赖于其他属性值，所以我们可以在计算属性中监听这些属性值的变化，并执行一些相关的操作 。 但是，计算属性无法直接监听另一个计算属性的变化，因为一个<code>计算属性的值不是响应式的</code>，它依赖的属性值发生变化时只有它自己才会重新计算，而不会触发其他计算属性的更新</p></blockquote> <h1 id="六、typescript篇"><a href="#六、typescript篇" class="header-anchor">#</a> 六、TypeScript篇</h1> <p>=============</p> <h3 id="_1-typescript基本数据类型"><a href="#_1-typescript基本数据类型" class="header-anchor">#</a> 1.TypeScript基本数据类型</h3> <blockquote><p>原始数据类型：</p> <ul><li>boolean 布尔值</li> <li>number 数值</li> <li>string 字符串</li> <li>null 空值</li> <li>undefined 未定义</li> <li>Symbol （ES6 中的新类型）</li></ul> <p>非原始数据类型：</p> <ul><li><p>数组 arr: number[] arr: Array</p></li> <li><p>Tuple 元祖 x: [string, number]</p></li> <li><p>enum 枚举</p> <p>enum Color {Red, Green, Blue};
let c: Color = Color.Blue;//默认情况下，从 0 开始为元素编号。
console.log(c);    // 输出 2</p> <p>enum Person {
name = &quot;NAME&quot;,
age = &quot;AGE&quot;,
love = &quot;LOVE&quot;,
hobby = &quot;HOBBY&quot;,
}
console.log(Person.name); // NAME
console.log(Person.hobby); // HOBBY</p></li> <li><p>never 永不存在的值的类型</p></li> <li><p>void</p> <p>//void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void。
function hello(): void {
alert(&quot;Hello ts&quot;);
}</p></li> <li><p>any 任意类型</p></li> <li><p>联合类型</p> <p>//联合类型（Union Types）表示取值可以为多种类型中的一种。
let num: string | number;
num = &quot;seven&quot;;
num = 7;</p></li> <li><p>函数类型</p></li> <li><p>unknown 表示一个未知的类型,使用<code>unknown</code>标注的变量和参数必须经过类型检查和转换后才能使用。</p></li></ul></blockquote> <h3 id="_2-void和undefined"><a href="#_2-void和undefined" class="header-anchor">#</a> 2.void和undefined</h3> <div class="language- extra-class"><pre><code>let unde: void = undefined;
let nu: void = null;

let un: undefined = undefined;
let nu: null = null;

//与 void 的区别是，undefined是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量

let num: number = undefined;

let un: undefined;
let num2: number = un;
</code></pre></div><h3 id="_3-typescript类修饰符"><a href="#_3-typescript类修饰符" class="header-anchor">#</a> 3.TypeScript类修饰符</h3> <blockquote><p>TypeScript支持访符 public，private 和 protected，它们决定了类成员的可访问性。</p> <p>public(公共)：所有定义成public的属性和方法都可以在任何地方进行访问。</p> <p>private(私有)：所有定义成private的属性和方法都只能在类定义内部进行访问。</p> <p>protected(受保护)： 该类及其子类的所有成员都可以访问它们。 但是该类的实例无法访问</p></blockquote> <h3 id="_4-如何定义一个数组-它的元素可能是字符串类型-也可能是数值类型"><a href="#_4-如何定义一个数组-它的元素可能是字符串类型-也可能是数值类型" class="header-anchor">#</a> 4.如何定义一个数组，它的元素可能是字符串类型，也可能是数值类型</h3> <div class="language- extra-class"><pre><code>//通过不同方式使用联合类型写法  |

// 方法1：
let arr1: (number | string)[] = [1]
arr1.push(1)
arr1.push('3')

// 方法2：
let  arr2 : Array&lt;string | number&gt; = [1, '2']
arr2.push(1)
arr2.push('3')

// 方法3：
type newType = number|string
let arr3:newType []= [3]
arr3.push(1)
arr4.push('5')
</code></pre></div><h3 id="_5-typescript接口"><a href="#_5-typescript接口" class="header-anchor">#</a> 5.TypeScript接口</h3> <blockquote><p>接口是一系列抽象方法的声明，是一些<code>方法特征的集合</code>，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。</p></blockquote> <div class="language- extra-class"><pre><code>//接口定义 interface
interface interface_name { 
}


//以下实例中，我们定义了一个接口 IPerson，接着定义了一个变量 customer，它的类型是 IPerson。
//customer 实现了接口 IPerson 的属性和方法。
interface IPerson { 
    firstName:string, 
    lastName:string, 
    sayHi: ()=&gt;string 
} 
 
var customer:IPerson = { 
    firstName:&quot;Tom&quot;,
    lastName:&quot;Hanks&quot;, 
    sayHi: ():string =&gt;{return &quot;Hi there&quot;} 
} 
 
console.log(&quot;Customer 对象 &quot;) //Customer 对象
console.log(customer.firstName) //Tom
console.log(customer.lastName)//Hanks
console.log(customer.sayHi()) //Hi there
</code></pre></div><h3 id="_6-typescript对象和typescript接口的区别"><a href="#_6-typescript对象和typescript接口的区别" class="header-anchor">#</a> 6.TypeScript对象和TypeScript接口的区别</h3> <blockquote><p>对象：对象是TS中一种数据类型，可以用来<code>存储多个数据属性和方法</code>，并且可以通过对象字面量或者构造函数来创建实例</p> <p>接口：接口是TS中定义<code>数据结构的规范</code>，主要用于描述对象的形状，即对象应该包含哪些属性和方法，但不提供实现。接口可以作为一个契约，确保其他代码符合其规范</p></blockquote> <div class="language- extra-class"><pre><code>//对象
let person = {
  name: &quot;Tom&quot;,
  age: 18,
  sayHi: function() {
    console.log(&quot;Hi&quot;);
  }
};

console.log(person.name); // Tom
person.sayHi(); // Hi

//接口
interface Person {
  name: string;
  age: number;
  sayHi(): void;
}

let person: Person = {
  name: &quot;Tom&quot;,
  age: 18,
  sayHi() {
    console.log(&quot;Hi&quot;);
  }
};

console.log(person.name); // Tom
person.sayHi(); // Hi
</code></pre></div><p><a href="https://blog.csdn.net/time_____/article/details/129345409?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168549915516800215067046%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168549915516800215067046&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129345409-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=typescript%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreferrer">类型别名及类型符号csdn详情参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_7-typescript类型别名"><a href="#_7-typescript类型别名" class="header-anchor">#</a> 7.TypeScript类型别名</h3> <blockquote><p>上述介绍了ts中的数据类型和接口，但是在开发过程中 <strong>不可避免的会遇到各种复杂类型</strong> ， 有些数据类型更灵活、复杂，那么此时，类型别名是一种<strong>非常有用的工具</strong>，它可以帮助我们简化代码，提高代码的可读性和可维护性</p> <p>基本用法： <code>type 类型名 = 类型值</code></p></blockquote> <div class="language- extra-class"><pre><code>type Name = string;
type Age = number;
type Person = {
  name: Name;
  age: Age;
  sayHi(): void;
};

let person: Person = {
  name: &quot;Tom&quot;,
  age: 18,
  sayHi() {
    console.log(&quot;Hi&quot;);
  }
};

console.log(person.name); // Tom
person.sayHi(); // Hi
</code></pre></div><h3 id="_8-typescript字面量类型"><a href="#_8-typescript字面量类型" class="header-anchor">#</a> 8.TypeScript字面量类型</h3> <p><strong>字面量类型（Literal Types）用来表示具体的字面量值，包括字符串、数字、布尔值等。它们可以作为类型注解的一部分，用来限制变量、函数参数、函数返回值等的取值范围</strong></p> <ul><li><p>数字字面量，字符串字面量，布尔字面量,空值字面量,枚举字面量</p> <div class="language- extra-class"><pre><code>//数字字面量
type Num = 10
const num: Num = 10
const num2: Num = 20 // 抛错，不能将20赋值给类型10

//字符串字面量
type Str = &quot;a&quot;
const num: Str = &quot;a&quot;

//布尔字面量
type Bool = false
const bool: Bool = false

//空值字面量
type Void = void;
const isNull: Void = null
const isUndefined: Void = undefined
const isVoid: Void = void 0

//枚举字面量
enum Color {
    Red = 1,
    Green,
    Blue
}
type colorBlue = Color.Blue
const blue: colorBlue = 3
</code></pre></div></li></ul> <h3 id="_9-typescript类型符号"><a href="#_9-typescript类型符号" class="header-anchor">#</a> 9.TypeScript类型符号</h3> <blockquote><p>TypeScript中的类型符号是用来声明变量类型的符号，主要有以下几种：</p> <ol><li><code>:</code>：用于声明变量的类型，例如：<code>let a: number = 10;</code> 表示声明一个名为a的变量，并将其类型标注为number。</li> <li><code>?</code>：用于表示某个属性或参数是可选的，例如：<code>interface Person { name: string; age?: number; }</code> 表示Person接口的age属性是可选的。</li> <li><code>[]</code>：用于表示数组类型，例如：<code>let arr: number[] = [1, 2, 3];</code> 表示声明一个名为arr的数组，其中元素类型为number。</li> <li><code>()</code>：用于表示函数类型，例如：<code>function add(a: number, b: number): number { return a + b; }</code> 表示声明一个名为add的函数，其中参数a和b的类型均为number，返回值类型也为number。</li> <li><code>|</code>：用于表示联合类型，例如：<code>let c: number | boolean = 10;</code> 表示声明一个名为c的变量，其类型为number或者boolean。</li> <li><code>&amp;</code>：用于表示交叉类型，例如：<code>interface A { a: number; } interface B { b: string; } type C = A &amp; B;</code> 表示定义一个名为C的交叉类型，它同时包含A和B两个接口的属性和方法</li></ol></blockquote> <h3 id="_10-typescript交叉类型"><a href="#_10-typescript交叉类型" class="header-anchor">#</a> 10.TypeScript交叉类型</h3> <blockquote><p>交叉类型（Intersection Types）可以用来将多个类型合并为一个类型。交叉类型使用<code>且符号&amp;</code>进行连接两个或多个类型；值得注意的是<strong>交叉类型一般使用于对象定义这种复杂的数据类型，如果使用交叉类型定义基础类型，则会转换为never类型</strong>，因为一个类型不可能同时兼备两种基础类型</p> <p><code>&amp; 连接的是简单联合类型，则产生的新类型是 &amp; 符号两边类型的公有类型。</code></p></blockquote> <div class="language- extra-class"><pre><code>//交叉基础类型，错误示范
type str = string
type num = number
type StrAndNum = str &amp; num // never类型

//正确示范
type information = {
    name: string
    age?: number  //?是可选类型，可以下放交叉不使用
}
type information2 = {
    readonly address: string
}
 
type user = information &amp; information2
 
const whiteDog: WhiteDog = {
    name: &quot;lc&quot;,
    address: &quot;中国&quot;,
}

//` &amp; 连接的是简单联合类型
type A = string | number
type B = string[] | number
// C是A和B共有的类型，number类型
type C = A &amp; B
</code></pre></div><h3 id="_11-泛型对象"><a href="#_11-泛型对象" class="header-anchor">#</a> 11.泛型对象</h3> <blockquote><p>泛型：使用尖括号&lt;&gt;来声明类型参数 (可以有多个)来表示暂时未知的类型，在实际声明变量时传入相应的类型 (或者由TS自动推论) 来替换相应出现该类型参数的地方，从而将抽象的、未知的类型替换为具体的、已知的类型。一个类型参数指代一种类型，例如&lt;T,K,U,…&gt;分别指代一种暂时未知的类型。将泛型用于定义对象类型，便得到了泛型对象。</p></blockquote> <div class="language- extra-class"><pre><code>// 类型T代表一种暂时未知的类型
interface PersonInfo&lt;T&gt; {
  info: T
}
// 传入类型变量string，这时候string就会在相应的地方替换原来的T
let p1: PersonInfo&lt;string&gt; = {
  info: 'cc'
}

let p2: PersonInfo&lt;number&gt; = {
  info: 18
}

let p3: PersonInfo&lt;'男' | '女'&gt; = {
  info: &quot;男&quot;
}
</code></pre></div><p><strong>泛型同样可在类型别名中使用</strong>。而类型别名除了定义对象类型之外，还能用泛型来定义各种其它类型。因此，我们可以<strong>使用泛型嵌套来定义更为复杂的类型结构</strong></p> <h3 id="_12-类型断言"><a href="#_12-类型断言" class="header-anchor">#</a> 12.类型断言</h3> <blockquote><p>类型断言（Type Assertion）是一种显式地告诉编译器变量的类型的方式，它允许我们手动指定一个变量的类型，从而绕过TypeScript编译器对该变量类型的检查</p></blockquote> <div class="language- extra-class"><pre><code>//断言两种方式,&lt;&gt;和as

let str: unknown
const len: number = (&lt;string&gt;str).length

let str: unknown
const len: number = (str as string).length
</code></pre></div><p>个人理解：事先定义了一个变量为它设置了类型，但是在其它场景需要这个变量为其它类型为了避免报错通过<code>断言</code>指定它为需求类型</p> <h3 id="_13-unknown-类型"><a href="#_13-unknown-类型" class="header-anchor">#</a> 13. unknown 类型</h3> <blockquote><p>类型<code>unknown</code>表示一个未知的类型。与<code>any</code>类型不同，使用<code>unknown</code>标注的变量和参数必须经过类型检查和转换后才能使用。</p> <p>应用场景：</p> <ul><li>当我们不知道某个变量的类型时，在某些情况下可以先把它标注为<code>unknown</code>类型，并在使用前进行类型检查或类型转换。</li> <li>当我们编写一些通用的函数或库时，为了避免与不同的代码库之间发生类型冲突，可以使用<code>unknown</code>类型来定义变量和参数。</li></ul></blockquote> <div class="language- extra-class"><pre><code>function processValue(value: unknown) {
  if (typeof value === &quot;string&quot;) {
    console.log(value.toUpperCase());
  } else if (typeof value === &quot;number&quot;) {
    console.log(value.toFixed(2));
  }
}

let val1: unknown = &quot;hello&quot;;
processValue(val1); // 输出HELLO

let val2: unknown = 3.1415;
processValue(val2); // 输出3.14

let val3: unknown = true;
processValue(val3); // 编译时错误：boolean类型不能转换为string或number类型
</code></pre></div><p>从上面的例子中可以看出，如果不进行类型检查或类型转换，使用<code>unknown</code>类型的变量会导致编译时错误。但是，通过类型检查和转换，我们可以安全地使用这个变量并避免类型错误。</p> <h3 id="_14-函数重载"><a href="#_14-函数重载" class="header-anchor">#</a> 14.函数重载</h3> <blockquote><p>函数名称相同，但是参数的个数或者类型不同。</p></blockquote> <div class="language- extra-class"><pre><code>// 函数的定义
function add(num1: number, num2: number): number;
function add(num1: string, num2: string): string;

// 函数的实现
function add(num1: any, num2: any): any {
    return num1 + num2;
}
</code></pre></div><h3 id="_15-抽象类"><a href="#_15-抽象类" class="header-anchor">#</a> 15.抽象类</h3> <blockquote><p>通过<code>abstract</code>定义抽象类</p> <p>在 TypeScript 中，抽象类是一种特殊的类，它<code>本身不能被实例化，而只能被继承</code>。抽象类可以包含抽象方法（即只有方法签名，没有实现），用于定义一些基本的行为或约束子类必须实现的方法，以及普通的具体方法，用于提供一些默认的实现。</p></blockquote> <div class="language- extra-class"><pre><code>// 不可以 new Animal 只能继承抽象类
abstract class Animal {
  abstract makeSound(): void;
  move(distanceInMeters: number = 0) {
    console.log(`Animal moved ${distanceInMeters}m.`);
  }
}

class Dog extends Animal {
  makeSound() {
    console.log(&quot;Woof! Woof!&quot;);
  }
}

let dog = new Dog();
dog.makeSound(); //  &quot;Woof! Woof!&quot;
dog.move(10); // &quot;Animal moved 10m.&quot;
</code></pre></div><p>​</p> <h3 id="_16-类型守卫-typeof-以及-instanceof"><a href="#_16-类型守卫-typeof-以及-instanceof" class="header-anchor">#</a> 16.类型守卫，typeof 以及 instanceof</h3> <blockquote><p>typeof 类型守卫：使用 typeof 运算符可以判断一个变量的类型是 string、number、boolean、symbol 或 undefined。</p> <p>instanceof 类型守卫：使用 instanceof 运算符可以判断一个变量是否为指定类的实例。它的使用方法是在检测对象的同时指定一个构造函数作为比较对象</p></blockquote> <div class="language- extra-class"><pre><code>//typeof
function example(value: string | number) {
  if (typeof value === &quot;string&quot;) {
    console.log(`The value is a string: ${value}`);
  } else {
    console.log(`The value is a number: ${value}`);
  }
}
example(&quot;hello&quot;); // Output: &quot;The value is a string: hello&quot;
example(42); // Output: &quot;The value is a number: 42&quot;

//instanceof
class MyClass {}
function example(input: MyClass | string) {
  if (input instanceof MyClass) {
    console.log(&quot;The input is an instance of MyClass.&quot;);
  } else {
    console.log(`The input is a string: ${input}`);
  }
}
example(new MyClass()); // Output: &quot;The input is an instance of MyClass.&quot;
example(&quot;hello&quot;); // Output: &quot;The input is a string: hello&quot;
</code></pre></div><h3 id="_17-typescript-编译上下文"><a href="#_17-typescript-编译上下文" class="header-anchor">#</a> 17.TypeScript 编译上下文</h3> <blockquote><p>在 TypeScript 中，编译上下文是指编译器对源代码进行类型检查和转换时所使用的环境和规则</p> <p>编译上下文可以包含以下几个方面：</p> <ol><li>编译选项：编译器可以通过命令行参数或 tsconfig.json 文件等方式配置各种编译选项，包括输出目录、模块解析方式、生成的 JavaScript 版本等。</li> <li>类型检查：编译器会对源代码进行类型检查，以捕获可能的类型错误和提供更准确的类型推断。类型检查过程中涉及到类型系统、类型注解、类型推断等概念。</li> <li>类型转换：在编译过程中，TypeScript 会将源代码中使用的语言特性（如类、接口、泛型、枚举、命名空间等）转换成相应的 JavaScript 代码。这个过程中，编译器还会进行一些优化和调整。</li> <li>声明文件处理：TypeScript 支持使用声明文件来描述 JavaScript 库和模块的类型信息，以提高与第三方库的兼容性和开发效率。编译器会自动搜索项目中的声明文件，或者对于没有声明文件的库，也可以通过第三方工具自动生成。</li> <li>模块解析：在编译过程中，编译器需要解析模块之间的依赖关系，以便正确地生成相应的 JavaScript 代码文件。模块解析涉及到模块路径、模块别名、自定义解析等问题。</li></ol></blockquote> <h3 id="_18-tsconfig-json"><a href="#_18-tsconfig-json" class="header-anchor">#</a> 18.tsconfig.json</h3> <blockquote><p>tsconfig.json 是一个用于配置 TypeScript 编译器的配置文件。通过这个配置文件，可以指定编译器所使用的规则和选项，以实现自定义编译过程和调整输出结果</p></blockquote> <div class="language-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 基本选项 */</span>
    <span class="token property">&quot;target&quot;</span><span class="token operator">:</span> <span class="token string">&quot;es5&quot;</span><span class="token punctuation">,</span>                       <span class="token comment">/* 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' */</span>
    <span class="token property">&quot;module&quot;</span><span class="token operator">:</span> <span class="token string">&quot;commonjs&quot;</span><span class="token punctuation">,</span>                  <span class="token comment">/* 指定模块化代码生成方式: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext' */</span>
    <span class="token property">&quot;lib&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;es6&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dom&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token comment">/* 指定要包含在编译中的库文件，默认为所有支持的库 */</span>
    <span class="token property">&quot;outDir&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./dist&quot;</span><span class="token punctuation">,</span>                    <span class="token comment">/* 指定输出目录 */</span>
    <span class="token property">&quot;rootDir&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./src&quot;</span><span class="token punctuation">,</span>                    <span class="token comment">/* 指定源代码目录 */</span>
  
    <span class="token comment">/* 详细选项 */</span>
    <span class="token property">&quot;strict&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                        <span class="token comment">/* 启用所有严格类型检查选项 */</span>
    <span class="token property">&quot;noImplicitAny&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                 <span class="token comment">/* 在表达式和声明上有隐含的 any 类型时报错 */</span>
    <span class="token property">&quot;strictNullChecks&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>              <span class="token comment">/* 启用严格的 null 检查 */</span>
    <span class="token property">&quot;noImplicitThis&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                <span class="token comment">/* 当 this 表达式值为 any 类型的时候，生成一个错误 */</span>
    <span class="token property">&quot;alwaysStrict&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                  <span class="token comment">/* 以严格模式检查每个模块，并在模块内部启用 &quot;use strict&quot; */</span>
  
    <span class="token comment">/* 配置文件扩展选项 */</span>
    <span class="token property">&quot;resolveJsonModule&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>             <span class="token comment">/* 允许导入 .json 模块 */</span>
    <span class="token property">&quot;esModuleInterop&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>               <span class="token comment">/* 自动生成命名空间导入 (import * as module from &quot;module&quot;) */</span>
    <span class="token property">&quot;skipLibCheck&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>                    <span class="token comment">/* 跳过对声明文件的检查 */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>​</p> <h3 id="_19-typescript-和javascript区别"><a href="#_19-typescript-和javascript区别" class="header-anchor">#</a> 19.TypeScript 和JavaScript区别</h3> <blockquote><p>js没有重载概念，ts有可以重载</p> <p>ts增加了接口interface、泛型、类、类的多态、继承等</p> <p>ts对比js基础类型上，增加了 void/never/any/元组/枚举/以及一些高级类型</p></blockquote> <blockquote><p><code>选择学习</code></p> <ol><li>类型系统：TS 是一种拥有静态类型检查的编程语言，支持在代码中明确指定变量的数据类型、声明函数的输入和输出类型、定义接口和类等。而 JS 则是一种动态类型的语言，变量类型是在运行时动态确定的。</li> <li>编译方式：TS 是一种编译型语言，需要通过编译器将 TS 代码转换为等价的 JS 代码才能在浏览器或者 Node.js 中执行。而 JS 是一种解释型语言，直接由运行时解释执行。</li> <li>扩展语法：TS 支持 ECMAScript 标准中定义的所有语法，并且还提供了一些自己的扩展语法，例如枚举类型、泛型、元组类型等。JS 则不支持所有扩展语法，并且在新标准发布前需要等待浏览器厂商的实现或者使用 polyfill 进行补丁。</li> <li>开发工具：TS 具备良好的 IDE 集成、语法高亮、代码提示、错误检查等功能，开发体验更加友好。JS 的开发工具则相对简单，主要是一些文本编辑器和浏览器控制台。</li> <li>生态环境：TS 是由微软开发并维护的项目，有着全球范围内的活跃社区和丰富的第三方库。JS 则更加开放和自由，生态环境更加广泛和多样化。</li></ol></blockquote> <hr> <h1 id="七、-react篇"><a href="#七、-react篇" class="header-anchor">#</a> 七、 React篇</h1> <h3 id="_1-react理解"><a href="#_1-react理解" class="header-anchor">#</a> 1.react理解</h3> <ul><li>React，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案 ，是渐进式框架，采用mvc架构</li> <li>特性： JSX 语法 ， 单向数据绑定 ， 虚拟 DOM ， 声明式编程 ，组件化开发</li></ul> <h3 id="_2-react-router-里的-标签和-标签有什么区别"><a href="#_2-react-router-里的-标签和-标签有什么区别" class="header-anchor">#</a> 2.react-router 里的 标签和 标签有什么区别？</h3> <ul><li>react-router 接管了其默认的链接跳转行为，与传统的页面跳转有区别的是，Link 的 <strong>“跳转”</strong> 行为只会触发相匹配的对应的页面内容更新，而不会刷新整个页面。</li> <li>link做了哪些事：1.有onclick就执行onclick，2.click的时候阻止a标签默认事件，3.根据跳转href用history跳转，此时只是链接变了，并没有刷新页面</li></ul> <h3 id="_3-react-jsx转换成真实dom过程"><a href="#_3-react-jsx转换成真实dom过程" class="header-anchor">#</a> 3.React Jsx转换成真实DOM过程？</h3> <ul><li>首先我们知道Jsx代码是不会被浏览器识别的，最终都会转化为 React.createElement 形式，babel实现这个过程</li> <li>createElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个虚拟DOM对象</li> <li>ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM</li></ul> <h3 id="_4-react-router的理解-原理-常用的router组件有哪些"><a href="#_4-react-router的理解-原理-常用的router组件有哪些" class="header-anchor">#</a> 4.React Router的理解，原理？常用的Router组件有哪些？</h3> <ul><li>路由的本质就是页面的<code>URL</code>发生改变时，页面的显示结果可以根据<code>URL</code>的变化而变化，但是页面不会刷新</li> <li><code>react-router</code>主要分成了几个不同的包(这一块先不写了)</li> <li>常用router组件：
<ul><li>BrowserRouter、HashRouter ： 路由模式history，hash</li> <li>route： <code>Route</code>用于路径的匹配，然后进行组件的渲染</li> <li>Link、NavLink： 通常路径的跳转是使用<code>Link</code>组件 <code>NavLink</code>是在<code>Link</code>基础之上增加了一些样式属性，例如组件被选中时，发生样式变化 ( activeStyle , activeClassName )</li> <li>redirect:路由重定向</li> <li>switch： <code>swich</code>组件的作用适用于当匹配到第一个组件的时候，后面的组件就不应该继续匹配</li></ul></li></ul> <h3 id="_5-react生命周期"><a href="#_5-react生命周期" class="header-anchor">#</a> 5.react生命周期</h3> <ul><li><p>组件挂载时<br>
当组件实例被创建并插入DOM时，其生命周期调用顺序如下：</p> <p>constructor()<br>
static getDerivedStateFromProps()<br>
render()<br>
componentDidMount()</p></li> <li><p>组件更新时<br>
当组件的props或state发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p> <p>static getDerivedStateFromProps()<br>
shouldComponentUpdate()<br>
render()<br>
getSnapshotBeforeUpdate()<br>
componentDidUpdate()</p></li> <li><p>组件卸载时<br>
当组件从DOM中移除时会调用如下方法</p> <p>componentWillUnmount()</p></li></ul> <h3 id="_6-react新生命周期取代了哪些-为什么"><a href="#_6-react新生命周期取代了哪些-为什么" class="header-anchor">#</a> 6.react新生命周期取代了哪些？为什么？</h3> <p>React 新的生命周期方法主要是为了支持 Fiber 架构中的三个新概念而设计的： fiber节点，异步渲染，可中断性</p> <ul><li><p>getDerivedStateFromProps(静态方法) 取代了componentWillMount和 componentWillReceiveProps</p></li> <li><p>getSnapshotBeforeUpdate 取代了componentWillUpdate</p></li> <li><p>getDerivedStateFromProps 中禁止了组件去访问 this.props， 由于 <code>this.props</code> 可能在任何时刻发生变化，所以计算出来的 state 对象可能会与旧的 state 对象相同，从而导致状态更新无效和不必要的组件重新渲染。 在 <code>getDerivedStateFromProps</code> 方法中应该始终使用参数中的 <code>nextProps</code>，而不是 <code>this.props</code>。这样可以保证组件状态的计算是基于最新的 props，从而避免了状态更新无效和渲染性能的问题。</p></li> <li><p>getSnapshotBeforeUpdate 方法是在组件的 <code>render</code> 方法被调用后，在更新 DOM 之前被调用的 ，也就是说在 getSnapshotBeforeUpdate 中读取到的 <code>DOM 元素信息</code>是可以保证与componentDidUpdate 中一致的。</p></li></ul> <h3 id="_7-fiber架构的理解-解决了什么问题"><a href="#_7-fiber架构的理解-解决了什么问题" class="header-anchor">#</a> 7.Fiber架构的理解？解决了什么问题？</h3> <p>在 React 16 之前，VirtualDOM 的更新采用的是<code>Stack架构</code>实现的，也就是循环递归方式。不过，这种对比方式有明显的缺陷，就是一旦任务开始进行就无法中断，如果遇到应用中组件数量比较庞大，那么VirtualDOM 的层级就会比较深，带来的结果就是主线程被长期占用，进而阻塞渲染、造成卡顿现象。</p> <p><code>fiber</code>：为了避免出现卡顿等问题，我们必须保障在执行更新操作时计算时不能超过<code>16ms</code>，如果超过16ms，就需要先暂停，让给浏览器进行渲染，后续再继续执行更新计算。而Fiber架构就是为了支持“<code>可中断渲染</code>”而创建的。 <code>解决了react在渲染大量dom节点出现丢帧的问题</code></p> <p>React Fiber 与浏览器的交互流程如下图。</p> <p><img src="/assets/img/14992e85b6da4b06bc2076bf4b315522.d8292428.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fMDn4pwd-1685931424895)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1685850448945.png)]"></p> <ul><li>从架构角度：fiber是对react核心算法的重写(调和过程)</li> <li>从编码角度：fiber是react内部定义的一种<code>数据结构</code>，是fiber树结构的节点单位，react16新架构下的虚拟dom</li> <li>主要操作：
<ul><li>为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li> <li>增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li> <li>dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li></ul></li></ul> <p>在 Fiber 架构中，React 将组件的更新过程分为两个阶段：reconciliation 和 commit。其中 reconciliation 阶段主要负责计算出更新后的 Virtual DOM 树，并确定哪些组件需要进行重新渲染，而 commit 阶段则负责将 Virtual DOM 树的变化映射到真实的 DOM 上。</p> <p>总结：相比传统的Stack架构，Fiber 将工作划分为多个工作单元，每个工作单元在执行完成后依据剩余时间决定是否让出控制权给浏览器执行渲染。 并且它设置每个工作单元的优先级，暂停、重用和中止工作单元。 每个Fiber节点都是fiber tree上的一个节点，通过子、兄弟和返回引用连接，形成一个完整的fiber tree。</p> <h3 id="_8-react有状态组件和无状态组件的理解及使用场景-、"><a href="#_8-react有状态组件和无状态组件的理解及使用场景-、" class="header-anchor">#</a> 8.react有状态组件和无状态组件的理解及使用场景？、</h3> <ul><li>有状态组件
<ul><li>特点：
<ul><li>是类组件<br>
有继承<br>
可以使用 this<br>
可以使用 react 的生命周期<br>
使用较多, 容易频繁触发生命周期<a href="https://so.csdn.net/so/search?q=%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">钩子函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, 影响性能<br>
内部使用 state, 维护自身状态的变化, 有状态组件根据外部组件传入的 props 和自身的 state 进行渲染</li></ul></li> <li>使用场景：
<ul><li>需要使用到状态的<br>
需要使用状态操作组件的(无状态组件的也可以实现新版本 react hooks 也可实现)</li></ul></li> <li>总结:<br>
类组件可以维护自身的状态变量, 即组件的 state, 类组件还有不同的生命周期方法, 可以让开发者能够在组件的不同阶段(挂载、更新、卸载), 对组件做更多的控制。类组件则既可以充当无状态组件, 也可以充当有状态组件。当一个类组件不需要管理自身状态时, 也可称为无状态组件。</li></ul></li> <li>无状态组件
<ul><li>特点：
<ul><li>不依赖自身的状态 state<br>
可以是类组件或者函数组件<br>
可以完全避免使用 this 关键字(由于使用的是箭头函数事件无需绑定)<br>
有更高的性能, 当不需要使用生命周期钩子时, 应该首先使用无状态函数组件<br>
组件内部不维护 state, 只根据外部组件传入的 props 进行渲染的组件, 当 props 改变时, 组件重新渲染</li></ul></li> <li>使用场景
<ul><li>组件不需要管理 state, 纯展示</li></ul></li> <li>优点:<br>
简化代码、专注于 render<br>
组件不需要被实例化, 无生命周期, 提升性能, 输出(渲染)只取决于输入(属性), 无副作用<br>
视图和数据的解耦分离</li> <li>缺点:<br>
无法使用 ref<br>
无生命周期方法<br>
无法控制组件的重渲染, 因为无法使用 shouldComponentUpdate 方法, 当组件接受到新的属性时则会重渲染</li></ul></li></ul> <h3 id="_9-react-的事件合成"><a href="#_9-react-的事件合成" class="header-anchor">#</a> 9. React 的事件合成？</h3> <ul><li>所有事件都是委托在<code>id = root</code>的DOM元素中（网上很多说是在<code>document</code>中，<code>17</code>版本不是了）；</li> <li>在应用中所有节点的事件监听其实都是在<code>id = root</code>的DOM元素中触发；</li> <li><code>React</code>自身实现了一套事件冒泡捕获机制；</li> <li><code>React</code>实现了合成事件<code>SyntheticEvent</code>；</li> <li><code>React</code>在<code>17</code>版本不再使用事件池了（网上很多说使用了对象池来管理合成事件对象的创建销毁，那是<code>16</code>版本及之前）；</li> <li>事件一旦在<code>id = root</code>的DOM元素中委托，其实是一直在触发的，只是没有绑定对应的回调函数；</li></ul> <h3 id="_10-react组件之间如何通信"><a href="#_10-react组件之间如何通信" class="header-anchor">#</a> 10.React组件之间如何通信？</h3> <ol><li><strong>父组件向子组件通讯:</strong><br>
父组件可以向子组件传入<code>props</code>的方式，向子组件进行通讯。</li> <li><strong>子组件向父组件通讯:</strong><br> <code>props</code>+回调的方式，父组件向子组件传递<code>props</code>进行通讯，此<code>props</code>为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到?组件的作?域中。</li> <li><strong>兄弟组件通信:</strong><br>
兄弟组件之间的传递，则父组件作为中间层来实现数据的互通，通过使用父组件传递<br>
例：组件A – 传值 --&gt; 父组件 – 传值 --&gt; 组件B</li> <li><strong>跨层级通讯:</strong><br> <code>Context</code> 设计?的是为了共享那些对于?个<br>
组件树??是“全局”的数据，<br>
使用<code>context</code>提供了组件之间通讯的一种方式，可以共享数据，其他数据都能读取对应的数据<br>
例如当前认证的?户、主题或?选语?,对于跨越多层的全局数据通过 <code>Context</code> 通信再适合不过。</li> <li><strong>发布订阅者模式:</strong><br>
发布者发布事件，订阅者监听事件并做出反应,我们可以通过引?<code>event</code>模块进?通信。</li> <li><strong>全局状态管理工具:</strong><br>
借助<code>Redux</code>或者<code>Mobx</code>等全局状态管理?具进?通信,这种?具会维护?个全局状态中?<code>Store</code>,并根据不同的事件产?新的状态。</li></ol> <h3 id="_11-react服务端渲染怎么做-原理是什么"><a href="#_11-react服务端渲染怎么做-原理是什么" class="header-anchor">#</a> 11.React服务端渲染怎么做？原理是什么？</h3> <ul><li>服务端渲染(SSR)： 指由服务侧完成页面的 <code>HTML</code> 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程</li> <li>服务端渲染解决的问题：1.SEO由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面 2.加速首屏加载，解决首屏白屏问题</li> <li>React如何做服务端渲染？
<ul><li>手动搭建SSR框架</li> <li>使用成熟的SSR框架，如next.js</li></ul></li> <li>实现原理：
<ul><li><code>node server</code> 接收客户端请求，得到当前的请求<code>url</code> 路径，然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 <code>props</code>、<code>context</code>或者<code>store</code> 形式传入组件</li> <li>然后基于 <code>react</code> 内置的服务端渲染方法 <code>renderToString()</code>把组件渲染为 <code>html</code>字符串在把最终的 <code>html</code> 进行输出前需要将数据注入到浏览器端</li> <li>浏览器开始进行渲染和节点对比，然后执行完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 <code>html</code> 节点，整个流程结束</li></ul></li></ul> <h3 id="_12-使用-react-hooks-怎么实现类里面的所有生命周期"><a href="#_12-使用-react-hooks-怎么实现类里面的所有生命周期" class="header-anchor">#</a> 12.使用 React hooks 怎么实现类里面的所有生命周期？</h3> <ul><li>在 React 16.8 之前，函数组件也称为无状态组件</li></ul> <p><img src="/assets/img/3f863f3661224c41a4a3556cdd75cad2.6f535360.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TwL7GzRj-1685931424896)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1682042087354.png)]"></p> <h3 id="_13-react事件和原生事件的执行顺序"><a href="#_13-react事件和原生事件的执行顺序" class="header-anchor">#</a> 13.React事件和原生事件的执行顺序</h3> <ul><li>为什么会有合成事件：
<ul><li>在传统的事件里，不同的浏览器需要兼容不同的写法，在合成事件中<code>React</code>提供统一的事件对象，抹平了浏览器的兼容性差异</li> <li><code>React</code>通过顶层监听的形式，通过事件委托的方式来统一管理所有的事件，可以在事件上区分事件优先级，优化用户体验。React<code>在合成事件上对于</code>16<code>版本和</code>17`版本的合成事件有很大不同</li></ul></li> <li>执行顺序总结：
<ul><li><code>16</code>版本先执行原生事件，当冒泡到<code>document</code>时，统一执行合成事件，</li> <li><code>17</code>版本在原生事件执行前先执行合成事件捕获阶段，原生事件执行完毕执行冒泡阶段的合成事件,通过根节点来管理所有的事件，原生的阻止事件流会阻断合成事件的执行，合成事件阻止后也会影响到后续的原生执行</li></ul></li></ul> <h3 id="_14-为什么react元素有一个-type属性"><a href="#_14-为什么react元素有一个-type属性" class="header-anchor">#</a> 14.为什么react元素有一个$$type属性？</h3> <p>目的是为了防止 <code>XSS 攻击</code>。因为 <code>Synbol</code> 无法被序列化，所以 <code>React</code> 可以通过有没有 <code>$$typeof</code> 属性来断出当前的 <code>element</code> 对象是从数据库来的还是自己生成的。如果没有 <code>$$typeof</code> 这个属性，<code>react</code> 会拒绝处理该元素。</p> <h3 id="_15-setstate-是同步-还是异步的"><a href="#_15-setstate-是同步-还是异步的" class="header-anchor">#</a> 15.setState 是同步，还是异步的？</h3> <ul><li>react18之前：setState在不同情况下可以表现为异步或同步。在Promise的状态更新、js原生事件、setTimeout、setInterval…中是同步的。在react的合成事件中，是异步的。</li> <li>react18之后： setState都会表现为异步（即批处理）。</li> <li>解释react18之前：
<ul><li>原因： 在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。</li></ul></li></ul> <h3 id="_16-如何让-useeffect-支持-async-await"><a href="#_16-如何让-useeffect-支持-async-await" class="header-anchor">#</a> 16.如何让 useEffect 支持 async/await？</h3> <ul><li>为什么不支持？
<ul><li><code>effect function</code> 应该返回一个销毁函数（<code>return</code>返回的 <code>cleanup</code> 函数），如果 <code>useEffect</code> 第一个参数传入 <code>async</code>，返回值则变成了 <code>Promise</code>，会导致 <code>react</code> 在调用销毁函数的时候报错</li></ul></li> <li>useEffect如何支持async/await？
<ul><li>创建一个异步函数（<code>async...await</code> 的方式），然后执行该函数。</li></ul></li></ul> <h3 id="_17-react-中可以做哪些性能优化"><a href="#_17-react-中可以做哪些性能优化" class="header-anchor">#</a> 17. React 中可以做哪些性能优化？</h3> <ul><li><p>使用纯组件 – 纯组件是指那些不依赖于外部状态或引用的组件</p></li> <li><p>shouldComponentUpdate 优化</p></li> <li><p>不要使用内联函数定义（如果我们使用内联函数，则每次调用“<code>render</code>”函数时都会创建一个新的函数实例）</p> <div class="language- extra-class"><pre><code>function MyButton(props) {
  return (
    &lt;button onClick={() =&gt; console.log('Button clicked!')}&gt;
      {props.label}
    &lt;/button&gt;
  );
}
</code></pre></div></li> <li><p>避免使用内联样式属性；</p></li> <li><p>使用 immutable 不可变数据，在我们项目中使用引用类型时，为了避免对原始数据的影响，一般建议使用 shallowCopy 和 deepCopy 对数据进行处理，但是这样会造成 CPU 和 内存的浪费，所以推荐使用 immutable</p> <ul><li>优点：
<ul><li>降低了可变带来的复杂度</li> <li>节省内存 ，immutable 使用结构共享尽量复用内存，没有被引用的对象会被垃圾回收</li> <li>不会有并发问题(因为数据本身不可变)</li> <li>拥抱函数编程</li></ul></li></ul></li> <li><p>给子组件设置一个唯一的 key，因为在 diff 算法中，会用 key 作为唯一标识优化渲染</p></li> <li><p>使用 <code>React.memo</code> 进行组件记忆（<code>React.memo</code> 是一个高阶组件），对 于相同的输入，不重复执行；</p></li> <li><p>在函数组件中使用<code>useCallback</code>和<code>useMemo</code>来进行组件优化，依赖没有变化的话，不重复执行</p></li> <li><p>路由懒加载</p></li></ul> <h3 id="_18-react-和-vue-有什么区别"><a href="#_18-react-和-vue-有什么区别" class="header-anchor">#</a> 18.react 和 vue 有什么区别？</h3> <ul><li>区别：
<ul><li>React 的思路是 HTML in JavaScript 通过 JavaScript 来生成 HTML，所以设计了 JSX 语法，还有通过 JS 来操作 CSS</li> <li>Vue 是把 HTML，CSS，JavaScript 组合到一起，用各自的处理方式，Vue 有单文件组件，可以把 HTML、CSS、JS 写到一个文件中，HTML 提供了模板引擎来处理。</li> <li>React 整体是函数式的思想，在 React 中是单向数据流，推崇结合 immutable 来实现数据不可变。</li> <li>Vue 的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立 Watcher 来监听，当属性变化的时候，响应式的更新对应的虚拟 DOM。</li> <li>React 的性能优化需要手动去做，而Vue的性能优化是自动的，但是Vue的响应式机制也有问题，就是当 state 特别多的时候，Watcher 会很多，会导致卡顿。</li></ul></li> <li>共同点：
<ul><li>React 与 Vue 存在很多共同点，例如他们都是 JavaScript 的 UI 框架，组件化开发，单项数据流，声明式编程，虚拟dom</li></ul></li> <li>优势：
<ul><li>React
<ul><li>灵活性和响应性：它提供最大的灵活性和响应能力。</li> <li>丰富的JavaScript库：来自世界各地的贡献者正在努力添加更多功能。</li> <li>可扩展性：由于其灵活的结构和可扩展性，React已被证明对大型应用程序更好。</li> <li>不断发展： React得到了Facebook专业开发人员的支持，他们不断寻找改进方法。</li> <li>Web或移动平台： React提供React Native平台，可通过相同的React组件模型为iOS和Android开发本机呈现的应用程序。</li></ul></li> <li>Vue
<ul><li>易于使用： Vue.js包含基于HTML的标准模板，可以更轻松地使用和修改现有应用程序。</li> <li>更顺畅的集成：无论是单页应用程序还是复杂的Web界面，Vue.js都可以更平滑地集成更小的部件，而不会对整个系统产生任何影响。</li> <li>更好的性能，更小的尺寸：它占用更少的空间，并且往往比其他框架提供更好的性能。</li> <li>精心编写的文档：通过详细的文档提供简单的学习曲线，无需额外的知识; HTML和JavaScript将完成工作。</li> <li>适应性：整体声音设计和架构使其成为一种流行的JavaScript框架。</li> <li>它提供无障碍的迁移，简单有效的结构和可重用的模板。</li></ul></li></ul></li> <li>总结：
<ul><li>Vue 的响应式机制也有问题，当 state 特别多的时候，Watcher 会很多，会导致卡顿，所以大型应用（状态特别多的）一般用 React，更加可控。</li> <li>对于易用性来说，VUE 是更容易上手的，对于项目来说新人更容易接手。</li></ul></li></ul> <h3 id="_19-react-render方法的原理-在什么时候会触发"><a href="#_19-react-render方法的原理-在什么时候会触发" class="header-anchor">#</a> 19.React render方法的原理，在什么时候会触发？</h3> <p><strong>原理：</strong><br>
在类组件中<code>render</code>函数指的就是<code>render</code>方法；而在函数组件中，指的就是整个函数组件<br> <code>render</code>函数中的<code>jsx</code>语句会被编译成我们熟悉的js代码，在<code>render</code>过程中，<code>react</code>将新调用的<code>render</code>函数返回的树与旧版本的树进行比较，这一步是决定如何更新 DOM 的必要步骤，然后进行 <code>diff</code> 比较，更新dom树<br> <strong>触发机：</strong><br>
类组件调用 <code>setState</code> 修改状态<br>
函数组件通过<code>useState hook</code>修改状态<br>
一旦执行了<code>setState</code>就会执行<code>render</code>方法，<code>useState</code> 会判断当前值有无发生改变确定是否执行<code>render</code>方法，一旦父组件发生渲染，子组件也会渲染</p> <h3 id="_20-react-hooks-在使用上有哪些限制"><a href="#_20-react-hooks-在使用上有哪些限制" class="header-anchor">#</a> 20.React Hooks 在使用上有哪些限制？</h3> <ul><li>不要在循环、条件或嵌套函数中调用 Hook；</li> <li>在 React 的函数组件中调用 Hook。</li></ul> <h3 id="_21-react-hooks概述及常用的hooks介绍"><a href="#_21-react-hooks概述及常用的hooks介绍" class="header-anchor">#</a> 21.React Hooks概述及常用的Hooks介绍？</h3> <p>Hooks是React 16.8版本引入的新特性，它为函数组件添加了一些类似于类组件中的状态和生命周期方法的功能</p> <ul><li>useState：用于在函数组件中添加状态管理功能。它返回一个由当前状态值和更新函数组成的数组，我们可以通过该数组来获取和更新状态的值。</li> <li>useEffect：用于执行副作用操作，例如订阅事件、修改DOM等。它接受一个函数作为参数，该函数将在每次渲染完成后执行。</li> <li>useContext：用于在组件间共享数据，它接受一个上下文对象作为参数，然后返回该上下文对象中提供的数据。</li> <li>useReducer：用于对复杂状态进行管理。它接受一个reducer函数和初始状态作为参数，并返回一个由当前状态值和dispatch函数组成的数组。</li> <li>useCallback：用于缓存函数以提高性能，类似于React.memo。</li> <li>useMemo：用于缓存计算结果以提高性能，类似于记忆函数。</li> <li>useRef：用于引用DOM节点或保存任意可变值，它返回一个可变的ref对象。</li></ul> <h3 id="_22-说说react生命周期中有哪些坑-如何避免"><a href="#_22-说说react生命周期中有哪些坑-如何避免" class="header-anchor">#</a> 22.说说React生命周期中有哪些坑？如何避免？</h3> <ul><li><code>getDerivedStateFromProps</code> 容易编写反模式代码，使受控组件和非受控组件区分模糊</li> <li><code>componentWillMount</code> 在 <code>React</code> 中已被标记弃用，不推荐使用，主要的原因是因为新的异步架构会导致它被多次调用，所以网络请求以及事件绑定应该放到 <code>componentDidMount</code> 中</li> <li><code>componentWillReceiveProps</code> 同样也被标记弃用，被 <code>getDerivedStateFromProps</code> 所取代，主要原因是性能问题。</li> <li><code>shouldComponentUpdate</code> 通过返回 <code>true</code> 或者 <code>false</code> 来确定是否需要触发新的渲染。主要用于性能优化。</li> <li><code>componentWillUpdate</code> 同样是由于新的异步渲染机制，而被标记废弃，不推荐使用，原先的逻辑可结合 <code>getSnapshotBeforeUpdate</code> 与 <code>componentDidUpdate</code> 改造使用。</li> <li>如果在 <code>componentWillUnmount</code> 函数中忘记解除事件绑定，取消定时器等清理操作，容易引发 <code>bug</code>。</li> <li>如果没有添加错误边界处理，当渲染发生异常时，用户将会看到一个无法操作的白屏，所以一定要添加。</li></ul> <h3 id="_23-说说real-diff算法是怎么运作的"><a href="#_23-说说real-diff算法是怎么运作的" class="header-anchor">#</a> 23.说说Real diff算法是怎么运作的？</h3> <ul><li><code>Diff</code>算法是虚拟<code>DOM</code>的一个必然结果，它是通过新旧<code>DOM</code>的对比，将在不更新页面的情况下，将需要内容局部更新</li> <li><code>Diff</code>算法遵循深度优先，同层比较的原则</li> <li><strong><code>react</code>中<code>diff</code>算法主要遵循三个层级的策略：</strong><br> <strong>tree层级</strong>：DOM节点的跨层级操作不做优化，只对相同层节点进行比较，只有删除创建操作，没有移动操作<br> <strong>conponent 层级</strong>：如果是同一类的组件，则会继续往下进行diff运算，如果不是则直接删除组件下的所有子节点，创建新的<br> <strong>element 层级</strong>：对于比较同一层级的节点们，每个节点在对应的层级用唯一的<code>key</code>作为标识，通过key知道节点的变化，移动旧集合节点位置，更新为新集合节点位置</li></ul> <h3 id="_24-调和阶段setstate干了什么"><a href="#_24-调和阶段setstate干了什么" class="header-anchor">#</a> 24.调和阶段setState干了什么？</h3> <ul><li>代码中调用 <code>setState</code> 函数之后，<code>React</code> 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（<code>Reconciliation</code>）。</li> <li>经过调和过程，<code>React</code> 会以相对高效的方式根据新的状态构建 <code>React</code> 元素树并且着手重新渲染整个 UI 界面；</li> <li>在 <code>React</code> 得到元素树之后，<code>React</code> 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染；</li> <li>在差异计算算法中，<code>React</code> 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</li></ul> <h3 id="_25-使用-redux-有哪些原则"><a href="#_25-使用-redux-有哪些原则" class="header-anchor">#</a> 25.使用 redux 有哪些原则？</h3> <ul><li>单一数据源：整个应用的全局 state 被存储在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li> <li>State 是只读的：唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事情的普通对象。</li> <li>使用纯函数来执行修改：为了描述 action 如何改变 state tree，你需要编写纯的 reducers。</li></ul> <h3 id="_26-说说redux的实现原理是什么-写出核心代码"><a href="#_26-说说redux的实现原理是什么-写出核心代码" class="header-anchor">#</a> 26.说说redux的实现原理是什么，写出核心代码？</h3> <ul><li>将应用的状态统一放到<code>state</code>中，由<code>store</code>来管理<code>state</code>。</li> <li><code>reducer</code>的作用是 返回一个新的<code>state</code>去更新<code>store</code>中对用的<code>state</code>。</li> <li>按<code>redux</code>的原则,<code>UI层</code>每一次状态的<strong>改变</strong>都应通过<code>action</code>去触发，<code>action</code>传入对应的<code>reducer</code> 中，<code>reducer</code>返回一个新的<code>state</code>更新<code>store</code>中存放的<code>state</code>，这样就完成了一次状态的更新</li> <li><code>subscribe</code>是为<code>store</code>订阅<strong>监听函数</strong>，这些订阅后的监听函数是在每一次<code>dipatch</code>发起后依次执行</li> <li>可以添加中间件对提交的<code>dispatch</code>进行重写<br> <strong>核心API</strong></li> <li><code>createStore</code> 创建仓库，接受<code>reducer</code>作为参数</li> <li><code>bindActionCreator</code> 绑定<code>store.dispatch</code>和<code>action</code> 的关系</li> <li><code>combineReducers</code> 合并多个<code>reducers</code></li> <li><code>applyMiddleware</code> 洋葱模型的中间件,介于<code>dispatch</code>和<code>action</code>之间，重写<code>dispatch</code></li> <li><code>compose</code> 整合多个中间件</li></ul> <h3 id="_27-对redux中间件的理解-原理-常用中间件有哪些"><a href="#_27-对redux中间件的理解-原理-常用中间件有哪些" class="header-anchor">#</a> 27.对Redux中间件的理解？原理？常用中间件有哪些？</h3> <p><code>Redux</code>中，中间件就是放在就是在<code>dispatch</code>过程，在分发<code>action</code>进行拦截处理， 其本质上一个函数，对<code>store.dispatch</code>方法进行了改造，在发出 <code>Action</code> 和执行 <code>Reducer</code> 这两步之间，添加了其他功能</p> <p>实现原理：</p> <ul><li><code>applyMiddlewares</code>的源码 中我们可以看到 ，所有中间件被放进了一个数组<code>chain</code>，然后嵌套执行，最后执行<code>store.dispatch</code>。可以看到，中间件内部（<code>middlewareAPI</code>）可以拿到<code>getState</code>和<code>dispatch</code>这两个方法</li></ul> <p>常用中间件：</p> <ul><li><code>redux-thunk</code>：用于异步操作</li> <li><code>redux-logger</code>：用于日志记录</li></ul> <h3 id="_28-redux-和-vuex-有什么区别-它们有什么共同思想吗"><a href="#_28-redux-和-vuex-有什么区别-它们有什么共同思想吗" class="header-anchor">#</a> 28.Redux 和 Vuex 有什么区别，它们有什么共同思想吗？</h3> <ul><li>相同点：
<ul><li>state 共享数据</li> <li>流程一致：定义全局state，触发，修改state</li> <li>原理相似，通过全局注入store。</li></ul></li> <li>不同点：
<ul><li>实现原理：
<ul><li>Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改</li> <li>Redux 在检测数据变化的时候，是通过 diff 的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的</li></ul></li> <li>表现层：
<ul><li>vuex定义了state、getter、mutation、action四个对象；redux定义了state、reducer、action。</li> <li>vuex中state统一存放，方便理解；reduxstate依赖所有reducer的初始值</li> <li>vuex有getter,目的是快捷得到state；redux没有这层，react-redux mapStateToProps参数做了这个工作。</li> <li>vuex中mutation只是单纯赋值(很浅的一层)；redux中reducer只是单纯设置新state(很浅的一层)。他俩作用类似，但书写方式不同</li> <li>vuex中action有较为复杂的异步ajax请求；redux中action中可简单可复杂,简单就直接发送数据对象（{type:xxx, your-data}）,复杂需要调用异步ajax（依赖redux-thunk插件）。</li> <li>vuex触发方式有两种commit同步和dispatch异步；redux同步和异步都使用dispatch</li></ul></li></ul></li> <li>共同思想：
<ul><li>单一的数据源</li> <li>变化可以预测</li></ul></li></ul> <h3 id="_29-props和state相同点和不同点"><a href="#_29-props和state相同点和不同点" class="header-anchor">#</a> 29.props和state相同点和不同点？</h3> <p>不同点：<br>
props是只读的，只能由父组件传递给子组件，而不能在子组件中修改。而state是可变的，在组件内部可以通过setState方法来修改其值<br>
相同点：<br>
1.props和state都会触发渲染更新</p> <p>2.props和state都是纯JS对象（用typeof来判断，结果都是object）</p> <h3 id="_30-shouldcomponentupdate有什么作用"><a href="#_30-shouldcomponentupdate有什么作用" class="header-anchor">#</a> 30.shouldComponentUpdate有什么作用？</h3> <p>shouldComponentUpdate () 可以理解为是否触发渲染的阀门，当状态发生改变时会走到该生命周期，shouldComponentUpdate接收两个参数props，state分别是更新前和更新后的状态，可以判断前后是否发生改变返回true和false，来决定是否往下执行</p> <h3 id="_31-react的props-children使用map函数来遍历会收到异常显示-为什么-应该-如何遍历"><a href="#_31-react的props-children使用map函数来遍历会收到异常显示-为什么-应该-如何遍历" class="header-anchor">#</a> 31.React的props.children使用map函数来遍历会收到异常显示，为什么？应该 如何遍历</h3> <p>原因：在react.js中props.children不一定是数组</p> <ul><li>当前组件没有子节点 undefined</li> <li>有一个子节点 object</li> <li>多个子节点 array</li></ul> <p><strong>react资深提供了一个react.children.map()方法，可以安全遍历子节点对象。</strong></p> <h3 id="_32-谈谈你对immutable-js的理解"><a href="#_32-谈谈你对immutable-js的理解" class="header-anchor">#</a> 32.谈谈你对immutable.js的理解？</h3> <p>Immutable.js采用了 持久化数据结构 ，保证每一个对象都是不可变的，任何添加、修改、删除等操作都会生成一个新的对象，且通过 结构共享 等方式大幅提高性能</p> <h3 id="_33-redux原理、工作流程及其应用-三大原则"><a href="#_33-redux原理、工作流程及其应用-三大原则" class="header-anchor">#</a> 33.redux原理、工作流程及其应用，三大原则</h3> <p>redux： <strong>redux是专门用于集中式管理状态的javascript库</strong>，他并<code>不是</code>react的插件库。</p> <p>redux三大核心：</p> <ul><li><p>actions<br>
actions英文直译过来就是行动、动作的意思，那么我们就可以猜到他表示的是“怎么做”，简单来说actions就是一个对象，actions里面有两个属性分别为type和data：<br>
type：标识属性，值为字符串且唯一，必要属性（你想要做什么事情<br>
data：数据属性，值为任意类型，可选属性（你要做事情的数据</p> <p>那我们浅浅举个栗子：比如计算器你可以进行加1减2等操作，那么加减乘除这个操作就是你的type，数字就是你的数据</p></li> <li><p>store<br>
store有且只能有一个，他相当于一个最高指挥家，他负责把action动作交给对应的reducer进行执行，也就是说将state、action和reducer联系在一起的对象。</p></li> <li><p>reducer<br>
reducer用于将store发过来的action完成并将结果返回给store，他接收两个参数preState（旧状态）和action（动作）并返回一个newState（新状态）。</p></li></ul> <p>工作流程：当组件使用store中的数据需要发生变化时，告诉action生成动作对象，通过dispatch分发对象到store，store对需要使用的reducer进行绑定，然后将action分发到对应reducer上执行相应逻辑进行<code>数据覆盖</code>,再将store数据渲染</p> <p><img src="/assets/img/1c6d8c8a24d74c85806490f06fd719ca.2b5c4344.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RCrTATdZ-1685931424896)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1685666639607.png)]"></p> <blockquote><p><code>三大原则</code></p> <p>唯一数据源(state)</p> <p>数据源(state)只读</p> <p>通过纯函数(pure function)改变数据源(state)</p></blockquote> <h3 id="_34-react-redux原理-工作流程"><a href="#_34-react-redux原理-工作流程" class="header-anchor">#</a> 34.react-redux原理，工作流程</h3> <p><a href="https://blog.csdn.net/qq_41101870/article/details/124634337?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168558336416800225594617%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168558336416800225594617&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124634337-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=react-redux%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreferrer">react-redux实现过程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>react-redux执行流程详解：</p> <blockquote><p>初始化阶段：</p> <ul><li>创建 Redux store 对象，并将 Reducer 传入 createStore 函数中。</li> <li>创建一个 Provider 组件，并将 Redux store 对象作为 Provider 组件的 props 传入其中。</li> <li>将应用根组件包装在 Provider 组件中，并渲染整个应用。</li></ul> <p>运行阶段：</p> <ul><li><p>使用 <code>connect</code> 函数将组件与 Redux 中的 state 和 action creators 相连接，并将它们转化为组件的 props 属性</p> <p>import { connect } from 'react-redux';
import { addToCart } from '../actions';</p> <p>const Product = ({ product, addToCart }) =&gt; (
</p><div><h3>{product.name}</h3>
&lt;button onClick={() =&gt; addToCart(product)}&gt;Add to cart</div>
);<p></p> <p>const mapDispatchToProps = {
addToCart,
};</p> <p>export default connect(null, mapDispatchToProps)(Product);</p></li></ul> <p>更新阶段：</p> <ul><li>在 Store 的 dispatch 方法中，执行 action 并更新 Store 中的 state。</li> <li>React-Redux 根据 Store 中的新状态，检查哪些组件的 props 发生了变化。</li> <li>对于发生变化的组件，React-Redux 将触发相关的生命周期方法和 render 方法进行重新渲染。</li></ul></blockquote> <p>工作流程：</p> <p><img src="/assets/img/4c284d62ee5342179516ed658fdb92d6.4218ed4a.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MtS3uaUn-1685931424896)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1685667792598.png)]"></p> <h3 id="_35-react组件通讯的context"><a href="#_35-react组件通讯的context" class="header-anchor">#</a> 35.react组件通讯的context</h3> <p>使用步骤：</p> <ul><li><p>在顶层组件中创建一个 context 对象，并将需要共享的数据挂载到该对象上</p> <div class="language- extra-class"><pre><code>const MyContext = React.createContext(defaultValue);
</code></pre></div></li> <li><p>在顶层组件的 render 方法中，使用 <code>MyContext.Provider</code> 组件来包裹整个应用程序，并将共享的数据传递给 <code>value</code> 属性</p> <div class="language- extra-class"><pre><code>&lt;MyContext.Provider value={sharedData}&gt;
    &lt;App /&gt;
&lt;/MyContext.Provider&gt;
</code></pre></div></li> <li><p>在需要使用共享数据的组件中，使用 <code>MyContext.Consumer</code> 组件来接收 context 的 value 属性，并在 Consumer 的子元素中使用这些数据</p> <div class="language- extra-class"><pre><code>&lt;MyContext.Consumer&gt;
    {sharedData =&gt; (
        // 此处可以使用 sharedData 来操作共享数据
    )}
&lt;/MyContext.Consumer&gt;
</code></pre></div></li></ul> <h3 id="_36-react-redux中-provider-组件实现原理"><a href="#_36-react-redux中-provider-组件实现原理" class="header-anchor">#</a> 36.react-redux中 Provider 组件实现原理</h3> <p>React-Redux 中的 Provider 组件是一个 React 组件，它使用了 React 的 Context API 来实现数据的传递。Provider 组件提供一个 context 对象，它可以让嵌套在它内部的子组件都可以访问到这个 context 对象，并且可以通过它来获取到 Redux store 中的数据。</p> <h3 id="_37-react-redux中connect原理"><a href="#_37-react-redux中connect原理" class="header-anchor">#</a> 37.react-redux中Connect原理</h3> <p>connect 函数是将 React 组件与 Redux Store 进行连接的重要方法。它接收两个函数作为参数，并返回一个高阶组件，通过这个高阶组件可以将 Redux Store 和 React 组件关联起来。 (实现容器组件包裹ui组件)</p> <p>在原应用组件上包裹一层，使原来整个应用成为Provider的子组件，接收Redux的store作为props，通过context对象传递给子孙组件上的connect，它真正连接 Redux 和 React，它包在我们的容器组件的外一层，它接收上面 Provider 提供的 store 里面的 state 和 dispatch，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。</p> <div class="language- extra-class"><pre><code>//其中 mapStateToProps 和 mapDispatchToProps 是将 Store 和 action creator 映射到组件的 props 上的函数。
connect(mapStateToProps, mapDispatchToProps)(Product);
</code></pre></div><h3 id="_38-react-toolkit"><a href="#_38-react-toolkit" class="header-anchor">#</a> 38.react-toolkit</h3> <p>react-toolkit是一个官方维护的包含多个有用工具的 Redux 库，旨在使 React 和 Redux 的开发变得更加简单、高效和直观</p> <ol><li>简化 Redux 工作流</li></ol> <p><code>redux-toolkit</code> 提供了一种新的方式来编写 Redux 应用程序，该方式包含了常见的 Redux 模式，并通过封装样板代码来简化它们。这使得开发者可以更加专注于实现业务逻辑，而不必关心较低级别的细节。</p> <ol><li>内置常用中间件</li></ol> <p><code>redux-toolkit</code> 包含了 Redux 应用程序中常用的几个中间件，如 <code>redux-thunk</code> 中间件、<code>redux-saga</code> 中间件和 <code>redux-logger</code> 中间件，使开发者可以轻松地使用和配置这些中间件。</p> <ol><li>强制执行不可变性</li></ol> <p><code>redux-toolkit</code> 的 <code>createSlice</code> 函数在创建 reducer 时会自动使用不可变性（immutability）来更新 state，这避免了因直接修改 state 而产生的潜在错误。</p> <ol><li>自动生成 Redux action 类型</li></ol> <p><code>redux-toolkit</code> 提供了 <code>createSlice</code> 函数来创建 reducer，该函数还会自动为每个 action type 创建一个字符串常量，避免手动编写这些常量带来的冗余代码。</p> <ol><li>管理副作用</li></ol> <p><code>redux-toolkit</code> 提供了 <code>createAsyncThunk</code> 函数来创建具有异步副作用的 action，该函数自动处理异步流程，并可以在状态中跟踪每个异步操作的进度和结果。</p> <h3 id="_39-react-memo-和-usememo-的用法是什么-有哪些区别"><a href="#_39-react-memo-和-usememo-的用法是什么-有哪些区别" class="header-anchor">#</a> 39.React.memo() 和 useMemo() 的用法是什么，有哪些区别？</h3> <p><code>React.memo</code> 是一个高阶组件，它可以将一个纯函数组件，当组件的 props 没有变化时，会直接复用组件的渲染结果，从而避免不必要的渲染。</p> <div class="language- extra-class"><pre><code>//当 MyComponent 的 text 属性没有变化时，MemoizedComponent 就会复用之前的渲染结果，而不会重新渲染。
function MyComponent(props) {
  return &lt;div&gt;{props.text}&lt;/div&gt;;
}
const MemoizedComponent = React.memo(MyComponent);
</code></pre></div><p><code>useMemo</code> 是一个 Hook，它可以用于缓存计算结果，以避免重复计算。当传入的依赖项没有变化时，会直接返回缓存的结果。</p> <div class="language- extra-class"><pre><code>//如果 calculate 方法比较耗时，为了避免不必要的计算，我们可以使用 useMemo 来缓存计算结果：
function MyComponent({ a, b }) {
  const result = useMemo(() =&gt; calculate(a, b), [a, b]);
  return &lt;div&gt;{result}&lt;/div&gt;;
}
</code></pre></div><p>区别：</p> <p><code>React.memo</code> 和 <code>useMemo</code> 都可以用于优化 React 应用的性能，但是它们的优化对象和优化手段不同。<code>React.memo</code> 通过避免组件的不必要渲染来提高性能，而 <code>useMemo</code> 通过避免重复计算来提高性能。在实际开发中，需要根据具体场景和需求来选择适合的优化方法。</p> <h3 id="_40-usecallback-usememo区别"><a href="#_40-usecallback-usememo区别" class="header-anchor">#</a> 40.usecallback，usememo区别</h3> <p><code>useCallback</code> 用于缓存函数，以避免不必要的函数创建和渲染。当依赖项发生变化时，会返回一个新的函数引用，否则直接返回之前缓存的函数引用。</p> <div class="language- extra-class"><pre><code>const memoizedCallback = useCallback(() =&gt; {
  doSomething(a, b);
}, [a, b]);
</code></pre></div><p><code>useMemo</code> 用于缓存计算结果，以避免重复计算和渲染。当依赖项发生变化时，会重新计算并返回新的计算结果</p> <div class="language- extra-class"><pre><code>const memoizedValue = useMemo(() =&gt; {
  return heavyComputation(a, b);
}, [a, b]);
</code></pre></div><p><code>useCallback</code> 通过避免函数创建和渲染来提高性能，而 <code>useMemo</code> 通过避免重复计算和渲染来提高性能</p> <h3 id="_41-react使用ref"><a href="#_41-react使用ref" class="header-anchor">#</a> 41.react使用ref</h3> <p>ref 是用来访问 DOM 元素或组件实例的引用的一种方式。</p> <p><code>字符串回调</code></p> <div class="language- extra-class"><pre><code>class MyComponent extends React.Component {
  componentDidMount() {
    console.log(this.refs.myInput);
    // 输出：&lt;input type=&quot;text&quot; /&gt;
  }
  render() {
    return &lt;input type=&quot;text&quot; ref=&quot;myInput&quot; /&gt;;
  }
}
</code></pre></div><p><code>函数回调</code></p> <div class="language- extra-class"><pre><code>class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = null;
  }
  componentDidMount() {
    console.log(this.myRef);
    // 输出：&lt;input type=&quot;text&quot; /&gt;
  }
  render() {
    return &lt;input type=&quot;text&quot; ref={node =&gt; this.myRef = node} /&gt;;
  }
}
</code></pre></div><p><code>React.createRef</code></p> <div class="language- extra-class"><pre><code>class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  componentDidMount() {
    console.log(this.myRef.current);
    // 输出：&lt;input type=&quot;text&quot; /&gt;
  }
  render() {
    return &lt;input type=&quot;text&quot; ref={this.myRef} /&gt;;
  }
}
</code></pre></div><h3 id="_42-为什么循环和判断不能使用hooks"><a href="#_42-为什么循环和判断不能使用hooks" class="header-anchor">#</a> 42.为什么循环和判断不能使用hooks</h3> <p>原因：</p> <p>循环、条件语句等块级作用域会影响 Hooks 调用的次数和顺序，从而破坏 React 内部的依赖关系和渲染逻辑，导致组件出现无法预期的错误。因此，为了保证组件能够正常渲染和更新，我们需要遵循 React Hooks 的使用规范，在顶层作用域中调用 Hooks。</p> <h3 id="_43-react实现过度动画"><a href="#_43-react实现过度动画" class="header-anchor">#</a> 43.React实现过度动画</h3> <p>使用第三方库： React Transition Group <a href="https://blog.csdn.net/jyl919221lc/article/details/128914897?spm=1001.2014.3001.5502" target="_blank" rel="noopener noreferrer">详细学习过度动画<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>注意： CSSTransition 中类命名方式<code>classNames</code></p> <h3 id="_44-react懒加载实现原理"><a href="#_44-react懒加载实现原理" class="header-anchor">#</a> 44. react懒加载实现原理</h3> <p>React 的懒加载实现原理主要是基于 ES6 的 <code>import()</code> 函数和 React 的 <code>lazy</code> 函数。</p> <div class="language- extra-class"><pre><code>import React, { lazy, Suspense } from &quot;react&quot;;

const LazyComponent = lazy(() =&gt; import(&quot;./LazyComponent&quot;));

function App() {
  return (
    &lt;div&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;LazyComponent /&gt;
      &lt;/Suspense&gt;
    &lt;/div&gt;
  );
}
</code></pre></div><p>当我们使用 <code>lazy</code> 函数时，React 会在运行时动态创建一个新的组件，这个新的组件继承了原始组件的所有属性和方法，并且它的 render 方法被重写成一个异步函数。当这个新的组件需要被渲染时，React 就会自动触发它的 render 方法，这个方法会异步加载原始组件的代码，并将其渲染到页面上。</p> <p>这里涉及到了 ES6 中的 <code>import()</code> 函数，它是一个异步函数，用来动态加载 JavaScript 模块。<code>import()</code> 函数会返回一个 Promise 对象，当模块加载完成后，Promise 对象就会被 resolve，我们可以通过 then 方法获取模块的默认导出对象。</p> <h3 id="_45-immutable"><a href="#_45-immutable" class="header-anchor">#</a> 45.immutable</h3> <p>Immutable 是一个 JavaScript 库，它提供了一些数据结构和 API，使得创建<code>不可变数据</code>成为可能。React 中使用 Immutable 可以带来以下好处：</p> <ul><li><strong>性能优化：</strong> React 中使用的 Virtual DOM 技术会频繁地进行比较和更新操作，而不可变数据可以减少需要更新的节点数量，从而提高应用的性能和响应速度。</li> <li><strong>便于管理状态：</strong> React 应用中的状态通常非常复杂，使用不可变数据可以更加方便地管理状态，并且避免了因为状态被修改而引发的副作用。</li> <li><strong>并发安全：</strong> 在高并发环境下，使用不可变数据可以减少数据竞争和锁竞争，提高并发安全性能。</li></ul> <p>immutable创建不可变数据类型，想要修改只能通过数据覆盖创建新的变量，对react进行性能优化</p> <h3 id="_46-usestate为什么返回数组而不是对象"><a href="#_46-usestate为什么返回数组而不是对象" class="header-anchor">#</a> 46.useState为什么返回数组而不是对象</h3> <p>原因：React 团队认为，使用数组可以带来更好的灵活性和易用性</p> <p>优点：</p> <ul><li><strong>无需命名：</strong> 当使用数组时，我们可以使用数组解构语法来命名状态变量和修改函数，并且不需要考虑命名冲突等问题。</li> <li><strong>直接修改：</strong> 使用数组解构后，我们可以直接对数组元素进行修改操作，而无需再次调用对象中的某个方法或属性。</li> <li><strong>易于扩展：</strong> 在未来的版本中，React 还可能会增加更多的状态相关的 Hook，使用数组可以使得新增的 Hook 更加容易添加到现有的语法中</li></ul> <h3 id="_47-类组件为什么不能使用hooks"><a href="#_47-类组件为什么不能使用hooks" class="header-anchor">#</a> 47.类组件为什么不能使用hooks</h3> <p>Hooks 是基于函数式编程思想设计的，不支持类组件的一些特性。但是，React 提供了一些方法，可以让开发者在类组件中使用 Hooks 的部分功能，或者将类组件转换为函数组件来使用 Hooks。</p> <h3 id="_48-redux-thunk和redux-saga区别"><a href="#_48-redux-thunk和redux-saga区别" class="header-anchor">#</a> 48.redux-thunk和redux-saga区别</h3> <p><code>redux-thunk</code> 的设计思路是将异步逻辑封装到“thunk”函数中，这个函数接收 <code>dispatch</code> 方法作为参数，并返回一个带有回调函数的函数。这个回调函数在异步操作完成后被调用，然后再通过 <code>dispatch</code> 方法触发一个 action，更新 Redux store 中的数据。<code>redux-thunk</code> 适合用于处理简单的异步逻辑，比如发送 AJAX 请求或者获取本地存储数据等。 没有拓展api</p> <p><code>redux-saga</code> 则采用了另外一种设计思路，它使用了 ES6 的 generator 函数来实现异步逻辑的管理。在 <code>redux-saga</code> 中，使用 generator 函数定义一个 saga，它可以监听一个或多个 action，并在相应的 action 被触发后执行一些副作用，比如发送 AJAX 请求、触发其他 action 等。<code>redux-saga</code> 还提供了一些辅助函数和特性(api)，比如 <code>takeLatest</code>、<code>put</code>、<code>call</code> 等，使得开发者可以更加方便地管理异步流程，处理错误和取消请求等。</p> <h3 id="_49-react合成事件使用原因-原理"><a href="#_49-react合成事件使用原因-原理" class="header-anchor">#</a> 49.react合成事件使用原因，原理</h3> <p><a href="https://blog.csdn.net/CRMEB/article/details/122918056?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168575476816782427416067%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168575476816782427416067&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-122918056-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=react%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreferrer">探索合成事件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>React 合成事件（SyntheticEvent）是 React 模拟原生 DOM 事件所有能力的一个事件对象</p> <p>使用原因：</p> <ul><li><p>进行浏览器兼容，实现更好的跨平台</p> <p>React 采用的是<code>顶层事件代理</code>机制，能够保证冒泡一致性，可以跨浏览器执行。React 提供的合成事件用来抹平不同浏览器事件对象之间的差异，将不同平台事件模拟合成事件。</p></li> <li><p>避免垃圾回收</p> <p>事件对象可能会被频繁创建和回收，因此 React 引入<code>事件池</code>，在事件池中获取或释放事件对象。即 React 事件对象不会被释放掉，而是存放进一个<code>数组</code>中，当事件触发，就从这个数组中弹出，避免频繁地去创建和销毁(垃圾回收)。</p></li> <li><p>方便事件统一管理和事务机制</p></li></ul> <p>原理：</p> <ul><li>事件绑定
<ul><li>在React17之前，React是把事件委托在document上的，React17及以后版本不再把事件委托在document上，而是委托在挂载的容器上</li> <li>原生事件和合成事件两者其实是通过一个叫事件插件（EventPlugin）的模块产生关联的，每个插件只处理对应的合成事件，比如onClick事件对应SimpleEventPlugin插件，这样React在一开始会把这些插件加载进来，通过插件初始化一些全局对象，比如其中有一个对象是registrationNameDependencies，它定义了合成事件与原生事件的对应关系</li></ul></li> <li>事件触发
<ul><li>事件触发都会执行dispatchEvent函数，当触发事件时会对当前元素的所有父元素处理构造成合成对象，将合成事件一次存放入eventQueue中，遍历 eventQueue 模拟一遍捕获和冒泡阶段，然后通过runEventsInBatch方法依次触发调用每一项的监听事件</li></ul></li></ul> <h3 id="_50-react事件代理机制"><a href="#_50-react事件代理机制" class="header-anchor">#</a> 50.React事件代理机制</h3> <p>React 并不会把所有的处理函数直接绑定在真实的节点上。而是把所有的事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。</p> <ul><li>所有事件都是委托在<code>id = root</code>的DOM元素中（网上很多说是在<code>document</code>中，<code>17</code>版本不是了）；</li> <li>在应用中所有节点的事件监听其实都是在<code>id = root</code>的DOM元素中触发；</li> <li><code>React</code>自身实现了一套事件冒泡捕获机制；</li> <li><code>React</code>实现了合成事件<code>SyntheticEvent</code>；</li> <li><code>React</code>在<code>17</code>版本不再使用事件池了（网上很多说使用了对象池来管理合成事件对象的创建销毁，那是<code>16</code>版本及之前）；</li> <li>事件一旦在<code>id = root</code>的DOM元素中委托，其实是一直在触发的，只是没有绑定对应的回调函数；</li></ul> <h3 id="_51-react事件和原生事件的执行顺序"><a href="#_51-react事件和原生事件的执行顺序" class="header-anchor">#</a> 51.React事件和原生事件的执行顺序</h3> <div class="language- extra-class"><pre><code>import React, { useRef, useEffect } from &quot;react&quot;;
import &quot;./styles.css&quot;;

const logFunc = (target, isSynthesizer, isCapture = false) =&gt; {
    const info = `${isSynthesizer ? &quot;合成&quot; : &quot;原生&quot;}事件，${
        isCapture ? &quot;捕获&quot; : &quot;冒泡&quot;}阶段，${target}元素执行了`;
    
    console.log(info);
};

const batchManageEvent = (targets, funcs, isRemove = false) =&gt; {
    targets.forEach((target, targetIndex) =&gt; {
        funcs[targetIndex].forEach((func, funcIndex) =&gt; {
            target[isRemove ? &quot;removeEventListener&quot; : &quot;addEventListener&quot;](
                &quot;click&quot;,
                func,
                !funcIndex
            );
        });
    });
};

export default function App() {
    const divDom = useRef();
    const h1Dom = useRef();
    useEffect(() =&gt; {
    
        const docClickCapFunc = () =&gt; logFunc(&quot;document&quot;, false, true);
        const divClickCapFunc = () =&gt; logFunc(&quot;div&quot;, false, true);
        const h1ClickCapFunc = () =&gt; logFunc(&quot;h1&quot;, false, true);
        const docClickFunc = () =&gt; logFunc(&quot;document&quot;, false);
        const divClickFunc = () =&gt; logFunc(&quot;div&quot;, false);
        const h1ClickFunc = () =&gt; logFunc(&quot;h1&quot;, false);

        batchManageEvent(
            [document, divDom.current, h1Dom.current],
            [
                [docClickCapFunc, docClickFunc],
                [divClickCapFunc, divClickFunc],
                [h1ClickCapFunc, h1ClickFunc]
            ]
        );

        return () =&gt; {
            batchManageEvent(
                   [document, divDom.current, h1Dom.current],
                [
                    [docClickCapFunc, docClickFunc],
                    [divClickCapFunc, divClickFunc],
                    [h1ClickCapFunc, h1ClickFunc]
                ],
                true
            );
        };
    }, []);

    return (
        &lt;div
          ref={divDom}
          className=&quot;App1&quot;
          onClickCapture={() =&gt; logFunc(&quot;div&quot;, true, true)}
          onClick={() =&gt; logFunc(&quot;div&quot;, true)}
        &gt;
          &lt;h1
            ref={h1Dom}
            onClickCapture={() =&gt; logFunc(&quot;h1&quot;, true, true)}
            onClick={() =&gt; logFunc(&quot;h1&quot;, true)}
          &gt;
            Hello CodeSandbox
          &lt;/h1&gt;
        &lt;/div&gt;
    );
}
</code></pre></div><p><code>React16</code></p> <p><img src="/assets/img/a405a22de5bd4a2981a0876d5ab88e8d.5f4483e2.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GA0PK8mf-1685931424897)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1685930695759.png)]"></p> <p><code>React17</code></p> <p><img src="/assets/img/8981982865ed4c12a10afbf626d0d0e4.daf102fe.png" alt="在这里插入图片描述"></p> <p><code>总结</code></p> <ul><li><code>16</code>版本先执行原生事件，当冒泡到<code>document</code>时，统一执行合成事件，</li> <li><code>17</code>版本在原生事件执行前先执行合成事件捕获阶段，原生事件执行完毕执行冒泡阶段的合成事件,通过根节点来管理所有的事件</li></ul> <h3 id="_52-jsx转换真实dom流程"><a href="#_52-jsx转换真实dom流程" class="header-anchor">#</a> 52.jsx转换真实dom流程</h3> <ul><li>使用React.createElement()或JSX编写React组件，实际上所有的JSX都会转换成React.createElement()，Babel完成转换过程</li> <li>createElement函数对key和ref等特殊的props进行处理，生成vDom</li> <li>ReactDOM.render将生成好的dom渲染到容器上，进行处理转化成真实dom</li></ul> <h3 id="_53-什么是jsx"><a href="#_53-什么是jsx" class="header-anchor">#</a> 53.什么是JSX？</h3> <p>JSX即JavaScript XML。一种在React组件内部构建标签的类XML语法。JSX为react.js开发的一套<code>语法糖</code>，也是react.js的使用基础。React在不使用JSX的情况下一样可以工作，然而使用JSX可以提高组件的可读性，因此推荐使用JSX。</p> <p>优点：</p> <ul><li>允许使用熟悉的语法来定义 HTML 元素树；</li> <li>提供更加语义化且移动的标签；</li> <li>程序结构更容易被直观化；</li> <li>抽象了 React Element 的创建过程；</li> <li>可以随时掌控 HTML 标签以及生成这些标签的代码；</li> <li>是原生的 JavaScript。</li></ul> <hr> <h1 id="八、微信小程序"><a href="#八、微信小程序" class="header-anchor">#</a> 八、微信小程序</h1> <h3 id="_1-请谈谈wxml与标准的html的异同"><a href="#_1-请谈谈wxml与标准的html的异同" class="header-anchor">#</a> 1. 请谈谈WXML与标准的html的异同？</h3> <p>(1) WXML是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作用类似于网页开发中的html</p> <ul><li><p>都是用来描述页面的结构</p></li> <li><p>都由标签，属性等构成</p></li> <li><p>标签名字不一样，且小程序标签更少，单一标签更多</p></li> <li><p>小程序多了一些wx:if这样的属性以及{{}}这样的表达式</p></li> <li><p>WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览</p></li></ul> <p>⑥ 组件封装不同，WXML对组件进行了重新封装</p> <p>⑦ 小程序运行在JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象</p> <h3 id="_2-请谈谈wxss和css的异同"><a href="#_2-请谈谈wxss和css的异同" class="header-anchor">#</a> 2. 请谈谈WXSS和CSS的异同？</h3> <p>(1) 新增了rpx尺寸单位，css中需要手动进行像素单位换算，例如rem</p> <p>(2) WXSS支持新的尺寸rpx，在不同大小的屏幕上小程序会自动进行换算</p> <p>(3) 提供了全局样式和局部样式，项目根目录中的app.wxss会作用于所有小程序页面，局部页面的.wxss样式仅对当前页面生效</p> <p>(4) WXSS仅支持部分css选择器：</p> <ul><li><p>类选择器，id选择器</p></li> <li><p>元素选择器</p></li> <li><p>并集选择器，后代选择器</p></li> <li><p>：：after和：：before等伪类选择器</p></li></ul> <h3 id="_3-请谈谈微信小程序主要目录和文件的作用"><a href="#_3-请谈谈微信小程序主要目录和文件的作用" class="header-anchor">#</a> 3.请谈谈微信小程序主要目录和文件的作用</h3> <p>(1) project.config.json： 项目配置文件，用得最多的就是配置是否开启https校验；</p> <p>(2) App.js ：设置一些全局的基础数据等，页面的脚本文件，存放页面的数据、事件处理函数等；</p> <p>(3) App.json ：当前页面的配置文件，配置窗口的外观 、表现等，页面中的配置项会覆盖 app.json的；</p> <p>(4) App.wxss ：公共样式，引入iconfont等；</p> <p>(5) pages： 里面包含一个个具体的页面；</p> <p>(6) index.json： (配置当前页面标题和引入组件等)；</p> <p>(7) index.wxml：页面的模板结构文件；</p> <p>(8) .wxss文件：当前页面的样式表文件；</p> <p>(9) index.js ：(页面的逻辑，请求和数据处理等)</p> <h3 id="_4-请谈谈小程序的双向绑定和vue的异同"><a href="#_4-请谈谈小程序的双向绑定和vue的异同" class="header-anchor">#</a> 4.请谈谈小程序的双向绑定和vue的异同</h3> <p>(1) 小程序双向绑定：首先通过 bindinput 绑定文本框的输入事件</p> <ul><li><p>在 data 中声明一个变量 content ，将其动态绑定成文本框的 value 值</p></li> <li><p>在 bindinput 事件中通过事件参数 e.detail.value 可以获取到文本框中最新的 value 值</p></li> <li><p>通过 this.setData 将文本框最新的 value 值 赋值给 动态绑定的value值 content 即可实现数据的双向绑定</p></li></ul> <p>(2) Vue双向绑定：首先为文本框绑定 @input 监听文本框的输入事件</p> <ul><li><p>为文本框动态绑定 value 属性，其值是在data中定义的变量</p></li> <li><p>在 @input绑定的事件中 通过事件参数 event.target.value 可以获取到 input 框中最新的value值</p></li> <li><p>将其重新获取到的 value 赋值给 value值动态绑定的那个变量</p></li></ul> <p>(3) 大体上区别不大，绑定事件不同，以及获取value值的具体方式不同，以及在小程序中设置data中的数据，<br>
需要调用 this.setData方法进行设置</p> <h3 id="_5-简单描述下微信小程序的相关文件类型"><a href="#_5-简单描述下微信小程序的相关文件类型" class="header-anchor">#</a> 5.简单描述下微信小程序的相关文件类型</h3> <p>(1) WXML(weixin Markup Language) 是框架设计的一套标签语言，结合基础组件，事件系统，可以构建出页面的结构。内容主要事微信自己定义的一套组件。</p> <p>(2) WXSS(WeiXin Style Sheets) 是一套样式语言，主要用于描述 WXML 的组件样式。</p> <p>(3) JS 逻辑处理，网络请求</p> <p>(4) json 小程序设置，静态配置</p> <p>(5) app.json 必须要有这个文件，此文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置tabBar 最少两个</p> <h3 id="_6-微信小程序有哪些传值-传递数据-方法"><a href="#_6-微信小程序有哪些传值-传递数据-方法" class="header-anchor">#</a> 6.微信小程序有哪些传值(传递数据)方法</h3> <p>(1) 使用全局变量传递数据</p> <p><img src="/assets/img/b5e0b7bcef404a6f9db6ea9e952c5970.e41a55d2.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sz0bA7rH-1685933800252)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps1.jpg)]"></p> <p>(2) 使用本地存储数据传递</p> <p><img src="/assets/img/01411efc63b647379aff70b124fe4055.e1a6cf3a.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nuOfAZKQ-1685933800254)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps2.jpg)]"></p> <p>(3) 使用路由传递数据</p> <p><img src="/assets/img/12498f9404a24cbd8a8e86fd961a7557.3dd89b13.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-w0Je0oG7-1685933800254)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps3.jpg)]"></p> <h3 id="_7-bindtap和catchtap区别"><a href="#_7-bindtap和catchtap区别" class="header-anchor">#</a> 7.Bindtap和catchtap区别？</h3> <p>(1) Bindtap和catchtap都属于点击事件函数，将事件绑定到组件上，点击组件后可以触发函数</p> <p>bindtap ：子元素使用bindtap绑定事件后，执行的时候，会冒泡到父元素（触发父元素上绑定的bingtap事件）</p> <p>catchtap ：不会冒泡到父元素上，阻止事件冒泡</p> <h3 id="_8-wx-navigateto-wx-redirectto-wx-switchtab-wx-navigateback-wx-relaunch-的区别"><a href="#_8-wx-navigateto-wx-redirectto-wx-switchtab-wx-navigateback-wx-relaunch-的区别" class="header-anchor">#</a> 8.wx.navigateTo(),wx.redirectTo(),wx.switchTab(),wx.navigateBack(),wx.reLaunch()的区别？</h3> <p>(1) wx.navigateTo(Object):保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html" target="_blank" rel="noopener noreferrer">wx.navigateBack<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 可以返回到原页面。小程序中页面栈最多十层</p> <p>(2) Wx.navigateBack():关闭当前页面，返回上一页面或多级页面。可通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/getCurrentPages.html" target="_blank" rel="noopener noreferrer">getCurrentPages<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 获取当前的页面栈，决定需要返回几层</p> <p>(3) wx.redirectTo():关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面</p> <p>(4) wx.switchTab():跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</p> <p>(5) wx.reLaunch():关闭所有页面，打开到应用内的某个页面</p> <h3 id="_9-微信小程序和h5区别"><a href="#_9-微信小程序和h5区别" class="header-anchor">#</a> 9.微信小程序和h5区别？</h3> <p>(1) 从开发的角度：H5和小程序的开发工具就非常不同，小程序都是依赖于微信客户端的，所以相对来说开发工具没有H5那么多；与标准的H5语言是不一样的；而且还独立了很多的原生app的组件，所以它在组件封装上与H5也都是有所不同</p> <p>(2) 从运行环境：网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的。</p> <p>(3) 服务器配置：因为小程序的性能会比H5 高一些，所以服务器的配置要求上来说，小程序的要求要比H5更高一些系统权限：因为微信能获取到更多的系统权限，如网络通信状态、数据缓存能力等，这些系统级权限都能与微信小程序无缝衔接，这也就是官方宣称的微信小程序能够拥有Native App（原生APP）的流畅性能。而H5 web应用对系统本身的权限的获取则相对少了很多，这一点恰巧是H5 web应用经常被诟病的地方。也因此，H5的大多数应用被圈定在业务逻辑简单、功能单一的范围上。</p> <p>(4) 标签名字：写 HTML 的时候，经常会用到的标签是 div, p, span，小程序的 WXML 用的标签是 view, button, text 等等，这些标签就是小程序给开发者包装好的基本能力。小程序多了一些 wx:if 这样的属性以及  这样的表达式在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。</p> <h3 id="_10-小程序和vue写法区别"><a href="#_10-小程序和vue写法区别" class="header-anchor">#</a> 10.小程序和vue写法区别？</h3> <p>(1) 事件定义区别：vue通过@绑定事件，小程序通过bind</p> <p>(2) 事件函数传值：vue传值直接写在函数括号中，微信小程序传值需要用data-自定义名字=</p> <p>(3) 关键字引用：vue中属性名前面加 “:” 或者 v-bind，微信小程序中只需要属性值加“{{}}”包起来就行</p> <p>(4) 指令使用方式：vue中通过v-使用，小程序中通过wx:使用</p> <h3 id="_11-rpx的理解"><a href="#_11-rpx的理解" class="header-anchor">#</a> 11.Rpx的理解：</h3> <p>(1) Rpx是微信小程序中响应单位</p> <p>(2) rpx是微信小程序独有的、解决屏幕自适应的尺寸单位</p> <p>(3) 可以根据屏幕宽度进行自适应，不论大小屏幕，规定屏幕宽为750rpx，再页面宽度750px时，1rpx = 1px</p> <h3 id="_12-微信小程序可以做dom操作吗"><a href="#_12-微信小程序可以做dom操作吗" class="header-anchor">#</a> 12.微信小程序可以做dom操作吗？</h3> <p>(1) 微信小程序不支持document.querySelect获取元素，因为微信小程序的渲染层和逻辑层是独立的，但是它内置了获取元素的两种方法</p> <blockquote><p>wx.createSelectorQuery()获取dom元素</p></blockquote> <p><img src="/assets/img/7c8b7f41f98c47f7bf38a30ab7deb563.788f0ab5.png" alt="在这里插入图片描述"></p> <h3 id="_13-小程序和vue区别"><a href="#_13-小程序和vue区别" class="header-anchor">#</a> 13.小程序和vue区别？</h3> <p>(1) 生命周期不一样，微信小程序生命周期比较简单</p> <p>(2) 数据绑定也不同，微信小程序数据绑定需要使用{{}}，vue 直接:就可以</p> <p>(3) 显示与隐藏元素，vue中，使用 v-if 和 v-show 控制元素的显示和隐藏，小程序中，使用wx-if 和hidden 控制元素的显示和隐藏</p> <p>(4) 事件处理不同，小程序中，全用 bindtap(bind+event)，或者 catchtap(catch+event) 绑定事件,vue：使用 v-on:event 绑定事件，或者使用@event 绑定事件</p> <p>(5) 数据双向绑定也不也不一样在 vue中,只需要再表单元素上加上 v-model,然后再绑定 data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是 vue非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个 data中声明的变量。</p> <h3 id="_14-小程序自定义tabbar理解"><a href="#_14-小程序自定义tabbar理解" class="header-anchor">#</a> 14.小程序自定义tabbar理解？</h3> <p>(1) 首先在挨批评。App.json中配置tabbar，开启custom 自定义tabbar，配置完之后创建custom-tab-bar文件，这时候会在小程序底部生成文件内容，给index.wxml添加tabBar的结构代码， 给index.js 添加数据配置 和 事件方法</p> <h3 id="_15-微信小程序如何设置缓存"><a href="#_15-微信小程序如何设置缓存" class="header-anchor">#</a> 15.微信小程序如何设置缓存？</h3> <p>(1) wx.getStorage/wx.getStorageSync 读取本地缓存，通过wx.setStorage/wx.setStorageSync 写数据到缓存，其中Sync后缀的接口表示是同步接口</p> <p><img src="/assets/img/0b26f5ff86d549a9bb1e98db2c6b10b3.107ba1d6.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UjVVNhG7-1685933800255)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps6.jpg)]"></p> <h3 id="_16-微信小程序如何进行网络请求"><a href="#_16-微信小程序如何进行网络请求" class="header-anchor">#</a> 16. 微信小程序如何进行网络请求？</h3> <p>(1) wx.request(Object object) 用于发送网络请求</p> <p><img src="/assets/img/8fc50715e89a4f0da3b6aef621b21d8b.3b1c8051.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6vERk9ZA-1685933800256)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps7.jpg)]"><br> <img src="/assets/img/3d67c47a714a42e58185ef852e08421b.3c820193.png" alt="在这里插入图片描述"></p> <h3 id="_17-小程序生命周期分为三个部分"><a href="#_17-小程序生命周期分为三个部分" class="header-anchor">#</a> 17. 小程序生命周期分为三个部分</h3> <p>(1) 应用级：</p> <ul><li><p>onLaunch：小程序初始化完成时触发，全局只触发一次</p></li> <li><p>onShow：小程序启动或切前台显示时触发</p></li> <li><p>onHide：小程序从前台进入后台时触发(如 切换到其他的App</p></li> <li><p>onError：小程序发生脚本错误或 API 调用报错时触发</p></li></ul> <p>(2) 页面级：</p> <ul><li><p>onLoad：页面加载时执行，只执行一次</p></li> <li><p>onShow：页面展示时执行，执行多次</p></li> <li><p>onReady：页面初次渲染时执行，只执行一次</p></li> <li><p>onHide：页面从前台进入后台时执行</p></li> <li><p>onUnload：页面卸载时执行</p></li></ul> <p>(3) 组件级：</p> <p><strong>+</strong> created（重要）：组件实例刚刚被创建好时触发</p> <p><strong>+</strong> attached（重要）：在组件完全初始化完毕、进入页面节点树后被触发</p> <ul><li><p>ready：在组件在视图层布局完成后执行</p></li> <li><p>moved：在组件实例被移动到节点树另一个位置时执行</p></li></ul> <p><strong>+</strong> detached（重要）：在组件离开页面节点树后被触发</p> <p>⑥ Error：每当组件方法抛出错误时执行</p> <h3 id="_18-微信小程序如何做模块化"><a href="#_18-微信小程序如何做模块化" class="header-anchor">#</a> 18. 微信小程序如何做模块化？</h3> <p>(1) 可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口</p> <p>(2) 需要使用这些模块的文件中，使用 require 将公共代码引入</p> <h3 id="_19-微信所有api都放在哪里-简单介绍几个"><a href="#_19-微信所有api都放在哪里-简单介绍几个" class="header-anchor">#</a> 19. 微信所有api都放在哪里，简单介绍几个</h3> <p>(1) 小程序全局对象是: wx，所有的 API 都保存在 wx 对象中</p> <p><img src="/assets/img/f85decea9b544fca98c447e3725b73d1.096d67af.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mRW0ErKF-1685933800257)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps9.jpg)]"></p> <h3 id="_20-微信小程序应用和页面生命周期触发顺序"><a href="#_20-微信小程序应用和页面生命周期触发顺序" class="header-anchor">#</a> 20. 微信小程序应用和页面生命周期触发顺序？</h3> <p><img src="/assets/img/de8ecb70da684a70a65421c016b64f40.1a63958f.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SetOuL28-1685933800257)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps10.jpg)]"></p> <h3 id="_21-微信小程序自定义组件使用"><a href="#_21-微信小程序自定义组件使用" class="header-anchor">#</a> 21. 微信小程序自定义组件使用</h3> <p>(1) 创建components文件夹</p> <p>(2) 创建组件文件(例tabs)，新建为component形式</p> <p>(3) 在tabs的json文件中设置component：true</p> <p>(4) 在需要引入的组件页面的json文件中，在usingComponent里面写键值对，组件名:路径</p> <p>(5) 在需要页面写入标签</p> <p>注意：WXML 节点标签名只能是小写字母、中划线和下划线的组合</p> <h3 id="_22-微信小程序事件通道使用"><a href="#_22-微信小程序事件通道使用" class="header-anchor">#</a> 22. 微信小程序事件通道使用</h3> <p>微信小程序事件通道（事件总线）是用于在小程序多个页面或组件之间通过触发事件进行通信的机制。通过wx.navigateTo或wx.redirectTo方法跳转到目标页面或组件时，传入events参数，并将它赋值为事件通道对象</p> <p><img src="/assets/img/6abb9f8852fc4e71ad9d5228846dab20.86dcdf1d.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LWAz2h0q-1685933800257)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps11.jpg)]"></p> <p><img src="/assets/img/a8ffab400f004111bbd942e9a642f90f.d0cfd451.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VzfZh1kT-1685933800258)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps12.jpg)]"></p> <h3 id="_23-小程序如何使用vant组件库"><a href="#_23-小程序如何使用vant组件库" class="header-anchor">#</a> 23. 小程序如何使用vant组件库</h3> <p>如果是以js为web页面脚本语言创建的小程序，本身不存在package.json文件，就不可以使用npm命令</p> <p>先通过npm init初始化npm，产生package.json文件</p> <p>通过vantweapp官网 npm下载组件库</p> <p>在微信小程序中通过工具构建npm</p> <p>移除app.json中“style”：“v2”，避免小程序样式高于vant导致样式混乱</p> <p>在app.json中usingComponents注册组件</p> <h3 id="_24-微信小程序父子传递"><a href="#_24-微信小程序父子传递" class="header-anchor">#</a> 24. 微信小程序父子传递</h3> <p><code>父传子</code>：通过父组件标签绑定属性，子组件在properties中接收属性</p> <p><img src="/assets/img/9dd6f4033acb4bf8b2301dc85492e3a5.034842af.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SGnddbyV-1685933800258)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps13.jpg)]"></p> <p><img src="/assets/img/fded252c1933477182f7c04fc71899cb.c0edd33c.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pWFBQ4kf-1685933800258)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps14.jpg)]"></p> <p><code>子传父</code>：通过父组件bind自定义事件，绑定自身函数，子组件在触发函数中通过this.triggerEvent(‘父组件bind事件名’,传递参数)传递给父组件绑定函数中</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tabs</span> <span class="token attr-name">tabs</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>{{tabs}}<span class="token punctuation">'</span></span> <span class="token attr-name">activeTab</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{{ativeTab}}<span class="token punctuation">&quot;</span></span> <span class="token attr-name">bindchkActive</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>chkTab<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">methods</span><span class="token operator">:</span><span class="token punctuation">{</span>
<span class="token comment">//子组件中设置方法，通过triggerEvent执行父组件bind绑定的自定义指令</span>
<span class="token function">chk</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">triggerEvent</span><span class="token punctuation">(</span><span class="token string">'chkActive'</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span>currentTarget<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
    
    <span class="token function">chkTab</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//父组件通过e.detail接受子组件传递数据</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token literal-property property">activeTab</span><span class="token operator">:</span>e<span class="token punctuation">.</span>datail<span class="token operator">*</span><span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_25-小程序授权登录"><a href="#_25-小程序授权登录" class="header-anchor">#</a> 25. 小程序授权登录</h3> <p><img src="/assets/img/502458e9fbd44ddd965a970d2753c7ab.a3b4dfbc.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-baqj9O2a-1685933800260)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps18.jpg)]"></p> <h3 id="_26-web-view"><a href="#_26-web-view" class="header-anchor">#</a> 26. web-view</h3> <p>web-view 是一个 web 浏览器组件，可以用来承载网页的容器，会自动铺满整个页面.</p> <p><img src="/assets/img/dc75ca1a83334c71be60d7ec55c35953.4c317d45.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VbtijeOG-1685933800260)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps19.jpg)]"></p> <p><img src="/assets/img/9159add7549a42db98da2488c8f2798f.79c48f52.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kPrz1aPz-1685933800260)(file:///C:\Users\lenovo\AppData\Local\Temp\ksohtml14876\wps20.jpg)]"></p> <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAioAAABVCAYAAABn28+OAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFFmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0NDg4LCAyMDIwLzA3LzEwLTIyOjA2OjUzICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjIuMCAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIzLTA4LTExVDEwOjI3OjUxKzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMy0wOC0xNVQxMToyMDo0MiswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMy0wOC0xNVQxMToyMDo0MiswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpmODcwMzE0Ni00NzM2LTJi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" alt="在这里插入图片描述"></p> <hr> <h1 id="九、webpack-篇"><a href="#九、webpack-篇" class="header-anchor">#</a> 九、Webpack 篇</h1> <h3 id="_1-谈谈你对webpack的理解-webpack是什么"><a href="#_1-谈谈你对webpack的理解-webpack是什么" class="header-anchor">#</a> 1. 谈谈你对Webpack的理解（Webpack是什么？）</h3> <p>Webpack 是一个 静态模块打包器，可以分析各个模块的依赖关系，项目中的所有资源皆为模块，通过分析模块间的依赖关系，在其内部递归构建出一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 <code>bundle</code>。最终编绎输出模块为 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等）。</p> <p>webpack 就像一条生产线,要经过一系列处理流程(loader)后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。<br>
插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。</p> <h4 id="webpack的主要作用如下"><a href="#webpack的主要作用如下" class="header-anchor">#</a> webpack的主要作用如下：</h4> <ul><li>模块打包 可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。</li> <li>编译兼容 在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less，.vue，.jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。</li> <li>能力扩展 通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。</li></ul> <h3 id="_2-webpack的打包过程-打包原理-构建流程"><a href="#_2-webpack的打包过程-打包原理-构建流程" class="header-anchor">#</a> 2. Webpack的打包过程/打包原理/构建流程？</h3> <ol><li>初始化：启动构建，读取与合并配置参数，加载plugin,实例化Compiler</li> <li>编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件中的内容，再找到该Module依赖的Module，递归的进行编译处理</li> <li>输出：将编译后的Module组合成Chunk,将Chunk转换成文件，输出到文件系统中</li></ol> <p><strong>细节：</strong></p> <p><strong>Webpack CLI</strong> 通过 yargs模块解析 CLI 参数，并转化为配置对象option（单入口：Object，多入口：Array），调用 webpack(option) 创建 compiler 对象。</p> <p>如果有 option.plugin，则遍历调用plugin.apply()来注册 plugin，</p> <p>判断是否开启了 watch，如果开启则调用 compiler.watch，否则调用 compiler.run，开始构建。</p> <p>创建 Compilation 对象来收集全部资源和信息，然后触发 make 钩子。</p> <p>make阶段从入口开始递归所有依赖，</p> <p>每次遍历时调用对应Loader翻译文件中内容，然后生成AST，遍历AST找到下个依赖继续递归，</p> <p>根据入口和模块之间关系组装chunk，输出到dist中的一个文件内。</p> <p>在以上过程中，webpack会在特定的时间点（使用<strong>tapable模块</strong>）广播特定的事件，插件监听事件并执行相应的逻辑，并且插件可以调用webpack提供的api改变webpack的运行结果</p> <h3 id="_3-loader的作用"><a href="#_3-loader的作用" class="header-anchor">#</a> 3. loader的作用</h3> <p>webpack中的<strong>loader是一个函数</strong>，主要为了<strong>实现源码的转换</strong>，所以loader函数会<strong>以源码作为参数</strong>，比如，将ES6转换为ES5，将less转换为css，然后再将css转换为js，以便能<strong>嵌入到html文件中</strong>。</p> <blockquote><p>默认情况下，webpack只支持对js和json文件进行打包，但是像css、html、png等其他类型的文件，webpack则无能为力。因此，就需要配置相应的loader进行文件内容的解析转换。</p></blockquote> <h3 id="_4-有哪些常见的loader-他们是解决什么问题的"><a href="#_4-有哪些常见的loader-他们是解决什么问题的" class="header-anchor">#</a> 4. 有哪些常见的Loader？他们是解决什么问题的？</h3> <p>常用的loader如下：</p> <ul><li>image-loader：加载并且压缩图片文件。</li> <li>less-loader：加载并编译 LESS 文件。</li> <li>sass-loader：加载并编译 SASS/SCSS 文件。</li> <li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性，使用css-loader必须要配合使用style-loader。</li> <li>style-loader：用于将 CSS 编译完成的样式，挂载到页面的 style 标签上。需要注意 loader 执行顺序，style-loader 要放在第一位，loader 都是从后往前执行。</li> <li>babel-loader：把 ES6 转换成 ES5</li> <li>postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀。</li> <li>eslint-loader：通过 ESLint 检查 JavaScript 代码。</li> <li>vue-loader：加载并编译 Vue 组件。</li> <li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li> <li>url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)。</li> <li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试。</li></ul> <h3 id="_5-plugin的作用"><a href="#_5-plugin的作用" class="header-anchor">#</a> 5. plugin的作用</h3> <p><strong>plugin是一个类</strong>，类中有一个<strong>apply()方法，主要用于</strong>Plugin的安装，可以在其中监听一些来自编译器发出的事件，在合适的时机做一些事情。</p> <blockquote><p>webpack中的plugin赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在webpack的不同阶段（钩子 / 生命周期），贯穿了webpack整个编译周期。目的在于「解决 loader 无法实现的其他事」。</p></blockquote> <h3 id="_6-有哪些常见的plugin-他们是解决什么问题的"><a href="#_6-有哪些常见的plugin-他们是解决什么问题的" class="header-anchor">#</a> 6. 有哪些常见的Plugin？他们是解决什么问题的？</h3> <ul><li>html-webpack-plugin：可以复制一个有结构的html文件，并自动引入打包输出的所有资源（JS/CSS）</li> <li>clean-webpack-plugin：重新打包自动清空 dist 目录</li> <li>mini-css-extract-plugin：提取 js 中的 css 成单独文件</li> <li>optimize-css-assets-webpack-plugin：压缩css</li> <li>uglifyjs-webpack-plugin：压缩js</li> <li>commons-chunk-plugin：提取公共代码</li> <li>define-plugin：定义环境变量</li></ul> <h3 id="_7-webpack中loader和plugin的区别"><a href="#_7-webpack中loader和plugin的区别" class="header-anchor">#</a> 7. Webpack中Loader和Plugin的区别</h3> <p><strong>运行时机</strong><br>
1.loader运行在编译阶段<br>
2.plugins 在整个周期都起作用</p> <p><strong>使用方式</strong><br>
Loader:1.下载 2.使用<br>
Plugin:1.下载 2.引用 3.使用</p> <blockquote><p>loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中；plugin赋予了webpack各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader无法实现的其他事。</p></blockquote> <blockquote><p>在运行时机上，loader 运行在打包文件之前；plugin则是在整个编译周期都起作用。</p></blockquote> <blockquote><p>在配置上，loader在module.rules中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性；plugin在 plugins中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</p></blockquote> <h3 id="_8-webpack的热更新是如何做到的-说明其原理"><a href="#_8-webpack的热更新是如何做到的-说明其原理" class="header-anchor">#</a> 8. webpack的热更新是如何做到的？说明其原理？</h3> <p>热更新的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上webpack-dev-server与浏览器之间维护了一个websocket，当本地资源发生变化时，webpack-dev-server会向浏览器推送更新，并带上构建时的hash，让客户端与上一次资源进行对比。客户端对比出差异后会向webpack-dev-server发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向webpack-dev-server发起 jsonp 请求获取该chunk的增量更新。</p> <p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader和vue-loader都是借助这些 API 实现热更新。</p> <blockquote><p>详细：<br>
1、在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。<br>
2、webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。<br>
3、webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念<br>
4、webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，<br>
同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。<br>
webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。<br>
5、决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</p></blockquote> <h3 id="_9-如何解决循环依赖问题"><a href="#_9-如何解决循环依赖问题" class="header-anchor">#</a> 9. 如何解决循环依赖问题</h3> <p>Webpack 中将 require 替换为 <em><strong>*webpack_require*</strong></em>，会根据 moduleId 到 installedModules 找是否加载过，加载过则直接返回之前的 export，不会重复加载。</p> <h3 id="_10-如何提高webpack构建速度"><a href="#_10-如何提高webpack构建速度" class="header-anchor">#</a> 10. 如何提高Webpack构建速度</h3> <h4 id="_1-代码压缩"><a href="#_1-代码压缩" class="header-anchor">#</a> 1. 代码压缩</h4> <blockquote><ul><li>JS 压缩<br>
webpack 4.0默认在生产环境的时候是支持代码压缩的，即mode=production模式下。实际上webpack 4.0默认是使用terser-webpack-plugin这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel参数，使用多进程压缩，加快压缩。</li> <li>CSS 压缩<br>
CSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等。可以使用另外一个插件：css-minimizer-webpack-plugin。</li> <li>HTML 压缩<br>
使用HtmlWebpackPlugin插件来生成 HTML 的模板时候，通过配置属性minify进行 html 优化。</li></ul></blockquote> <div class="language- extra-class"><pre><code>module.exports = {
plugin:[
  new HtmlwebpackPlugin({
    minify:{
      minifyCSS: false, // 是否压缩css
      collapseWhitespace: false, // 是否折叠空格
      removeComments: true // 是否移除注释
    }
  })
  ]
}
</code></pre></div><h4 id="_2-图片压缩"><a href="#_2-图片压缩" class="header-anchor">#</a> 2. 图片压缩</h4> <blockquote><p>配置<code>image-webpack-loader</code></p></blockquote> <h4 id="_3-tree-shaking"><a href="#_3-tree-shaking" class="header-anchor">#</a> 3. Tree Shaking</h4> <p>Tree Shaking是一个术语，在计算机中表示消除死代码，依赖于 ES Module 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）。在webpack实现Tree shaking有两种方案：</p> <p>usedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的</p> <div class="language- extra-class"><pre><code>module.exports = {
    ...
    optimization:{
        usedExports
    }
  }
</code></pre></div><p>使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知Terser在优化时，可以删除掉这段代码。</p> <p>sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用</p> <p>sideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性。如果sideEffects设置为false，就是告知webpack可以安全的删除未用到的exports。如果有些文件需要保留，可以设置为数组的形式，如：</p> <div class="language- extra-class"><pre><code>&quot;sideEffecis&quot;:[
    &quot;./src/util/format.js&quot;,
    &quot;*.css&quot; // 所有的css文件
]
</code></pre></div><h4 id="_4-缩小打包域"><a href="#_4-缩小打包域" class="header-anchor">#</a> 4. 缩小打包域</h4> <p>排除webpack不需要解析的模块，即在使用loader的时候，在尽量少的模块中去使用。可以借助 include和exclude这两个参数，规定loader只在那些模块应用和在哪些模块不应用。</p> <h4 id="_5-减少-es6-转为-es5-的冗余代码"><a href="#_5-减少-es6-转为-es5-的冗余代码" class="header-anchor">#</a> 5. 减少 ES6 转为 ES5 的冗余代码</h4> <p>使用<code>bable-plugin-transform-runtime</code>插件</p> <h4 id="_6-提取公共代码"><a href="#_6-提取公共代码" class="header-anchor">#</a> 6. 提取公共代码</h4> <p>通过配置CommonsChunkPlugin插件，将多个页面的公共代码抽离成单独的文件</p> <h4 id="_7-其他"><a href="#_7-其他" class="header-anchor">#</a> 7. 其他</h4> <p>组件懒加载、路由懒加载、开启gzip、公共的第三方包上cdn、配置cache缓存Loader对文件的编译副本、配置resolve提高文件的搜索速度（@: src）</p> <hr> <h1 id="十、性能优化篇"><a href="#十、性能优化篇" class="header-anchor">#</a> 十、性能优化篇</h1> <h3 id="_1-浏览器缓存优化"><a href="#_1-浏览器缓存优化" class="header-anchor">#</a> 1. 浏览器缓存优化</h3> <p>为了让<code>浏览器缓存</code>发挥最大作用，该策略尽量遵循以下五点就能发挥<code>浏览器缓存</code>最大作用。</p> <ul><li><strong>「考虑拒绝一切缓存策略」</strong>：<code>Cache-Control:no-store</code></li> <li><strong>「考虑资源是否每次向服务器请求」</strong>：<code>Cache-Control:no-cache</code></li> <li><strong>「考虑资源是否被代理服务器缓存」</strong>：<code>Cache-Control:public/private</code></li> <li><strong>「考虑资源过期时间」</strong>：<code>Expires:t/Cache-Control:max-age=t,s-maxage=t</code></li> <li><strong>「考虑协商缓存」</strong>：<code>Last-Modified/Etag</code></li></ul> <p><code>缓存策略</code>通过设置<code>HTTP</code>报文实现，在形式上分为**「强缓存/强制缓存」<strong>和</strong>「协商缓存/对比缓存」**。为了方便对比，笔者将某些细节使用图例展示，相信你有更好的理解。<br> <img src="/assets/img/80c0b755bd4f4b7f8cc4f9447f1a1bde.8f6e27d5.png" alt="在这里插入图片描述"><br> <img src="/assets/img/0bfe2b2f1ea54e1aa6bf08d2c932ca0a.443bb92f.png" alt="在这里插入图片描述"><br>
整个<code>缓存策略</code>机制很明了，<code>先走强缓存，若命中失败才走协商缓存</code>。若命中<code>强缓存</code>，直接使用<code>强缓存</code>；若未命中<code>强缓存</code>，发送请求到服务器检查是否命中<code>协商缓存</code>；若命中<code>协商缓存</code>，服务器返回304通知浏览器使用<code>本地缓存</code>，否则返回<code>最新资源</code>。</p> <p>有两种较常用的应用场景值得使用<code>缓存策略</code>一试，当然更多应用场景都可根据项目需求制定。</p> <ul><li><strong>「频繁变动资源」</strong>：设置<code>Cache-Control:no-cache</code>，使浏览器每次都发送请求到服务器，配合<code>Last-Modified/ETag</code>验证资源是否有效</li> <li><strong>「不常变化资源」</strong>：设置<code>Cache-Control:max-age=31536000</code>，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件</li></ul> <h3 id="_2-渲染层面性能优化"><a href="#_2-渲染层面性能优化" class="header-anchor">#</a> 2. 渲染层面性能优化</h3> <p>**「渲染层面」**的性能优化，无疑是如何让代码<code>解析更好执行更快</code>。因此笔者从以下五方面做出建议。</p> <ul><li><strong>「CSS策略」</strong>：基于CSS规则</li> <li><strong>「DOM策略」</strong>：基于DOM操作</li> <li><strong>「阻塞策略」</strong>：基于脚本加载</li> <li><strong>「回流重绘策略」</strong>：基于回流重绘</li> <li><strong>「异步更新策略」</strong>：基于异步更新</li></ul> <p>上述五方面都是编写代码时完成，充满在整个项目流程的开发阶段里。因此在开发阶段需时刻注意以下涉及到的每一点，养成良好的开发习惯，<code>性能优化</code>也自然而然被使用上了。</p> <p><code>渲染层面</code>的<code>性能优化</code>更多表现在编码细节上，而并非实体代码。简单来说就是遵循某些编码规则，才能将<code>渲染层面</code>的<code>性能优化</code>发挥到最大作用。</p> <p>**「回流重绘策略」**在<code>渲染层面</code>的<code>性能优化</code>里占比较重，也是最常规的<code>性能优化</code>之一。上年笔者发布的掘金小册《玩转CSS的艺术之美》使用一整章讲解<code>回流重绘</code>，本章已开通试读，更多细节请戳这里。</p> <h4 id="css策略"><a href="#css策略" class="header-anchor">#</a> CSS策略</h4> <ul><li>避免出现超过三层的<code>嵌套规则</code></li> <li>避免为<code>ID选择器</code>添加多余选择器</li> <li>避免使用<code>标签选择器</code>代替<code>类选择器</code></li> <li>避免使用<code>通配选择器</code>，只对目标节点声明规则</li> <li>避免重复匹配重复定义，关注<code>可继承属性</code></li></ul> <h4 id="dom策略"><a href="#dom策略" class="header-anchor">#</a> DOM策略</h4> <ul><li>缓存<code>DOM计算属性</code></li> <li>避免过多<code>DOM操作</code></li> <li>使用<code>DOMFragment</code>缓存批量化<code>DOM操作</code></li></ul> <h4 id="阻塞策略"><a href="#阻塞策略" class="header-anchor">#</a> 阻塞策略</h4> <ul><li>脚本与<code>DOM/其它脚本</code>的依赖关系很强：对``设置<code>defer</code></li> <li>脚本与<code>DOM/其它脚本</code>的依赖关系不强：对``设置<code>async</code></li></ul> <h4 id="回流重绘策略"><a href="#回流重绘策略" class="header-anchor">#</a> 回流重绘策略</h4> <ul><li>缓存<code>DOM计算属性</code></li> <li>使用类合并样式，避免逐条改变样式</li> <li>使用<code>display</code>控制<code>DOM显隐</code>，将<code>DOM离线化</code></li></ul> <h4 id="异步更新策略"><a href="#异步更新策略" class="header-anchor">#</a> 异步更新策略</h4> <ul><li>在<code>异步任务</code>中修改<code>DOM</code>时把其包装成<code>微任务</code></li></ul> <h3 id="_3-性能优化六大指标"><a href="#_3-性能优化六大指标" class="header-anchor">#</a> 3. 性能优化六大指标</h3> <p><code>六大指标</code>基本囊括大部分<code>性能优化</code>细节，可作为<code>九大策略</code>的补充。笔者根据每条<code>性能优化建议</code>的特征将<code>指标</code>划分为以下六方面。</p> <ul><li><strong>「加载优化」</strong>：资源在加载时可做的性能优化</li> <li><strong>「执行优化」</strong>：资源在执行时可做的性能优化</li> <li><strong>「渲染优化」</strong>：资源在渲染时可做的性能优化</li> <li><strong>「样式优化」</strong>：样式在编码时可做的性能优化</li> <li><strong>「脚本优化」</strong>：脚本在编码时可做的性能优化</li> <li><strong>「V8引擎优化」</strong>：针对<code>V8引擎</code>特征可做的性能优化</li></ul> <hr> <h1 id="十一、其他杂项篇"><a href="#十一、其他杂项篇" class="header-anchor">#</a> 十一、其他杂项篇</h1> <h3 id="_1-常见的浏览器内核有哪些"><a href="#_1-常见的浏览器内核有哪些" class="header-anchor">#</a> 1. 常见的浏览器内核有哪些？</h3> <blockquote><ul><li>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
<ul><li>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</li> <li>JS引擎则：解析和执行javascript来实现网页的动态效果。</li></ul></li> <li>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</li> <li>常见内核
<ul><li>Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称 MSHTML]</li> <li>Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite / SeaMonkey 等</li> <li>Presto 内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]</li> <li>Webkit 内核：Safari, Chrome等。 [ Chrome的：Blink（WebKit 的分支）]</li></ul></li></ul></blockquote> <h3 id="_2-网页前端性能优化的方式有哪些"><a href="#_2-网页前端性能优化的方式有哪些" class="header-anchor">#</a> 2. 网页前端性能优化的方式有哪些？</h3> <blockquote><p>1.压缩 css, js, 图片<br>
2.减少 http 请求次数， 合并 css、js 、合并图片（雪碧图）<br>
3.使用 CDN<br>
4.减少 dom 元素数量<br>
5.图片懒加载<br>
6.静态资源另外用无 cookie 的域名<br>
7.减少 dom 的访问（缓存 dom）<br>
8.巧用事件委托<br>
9.样式表置顶、脚本置低</p></blockquote> <h3 id="_3-网页从输入网址到渲染完成经历了哪些过程"><a href="#_3-网页从输入网址到渲染完成经历了哪些过程" class="header-anchor">#</a> 3. 网页从输入网址到渲染完成经历了哪些过程？</h3> <blockquote><p>大致可以分为如下7步：</p> <ul><li>输入网址；</li> <li>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；</li> <li>与web服务器建立TCP连接；</li> <li>浏览器向web服务器发送http请求；</li> <li>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；</li> <li>浏览器下载web服务器返回的数据及解析html源文件；</li> <li>生成DOM树，解析css和js，渲染页面，直至显示完成；</li></ul></blockquote> <h3 id="_4-线程与进程的区别"><a href="#_4-线程与进程的区别" class="header-anchor">#</a> 4. 线程与进程的区别？</h3> <blockquote><ul><li>一个程序至少有一个进程,一个进程至少有一个线程.</li> <li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li> <li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li> <li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li> <li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul></blockquote> <h3 id="_5-http常见的状态码"><a href="#_5-http常见的状态码" class="header-anchor">#</a> 5. HTTP常见的状态码？</h3> <blockquote><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>
200 OK 正常返回信息<br>
201 Created 请求成功并且服务器创建了新的资源<br>
202 Accepted 服务器已接受请求，但尚未处理<br>
301 Moved Permanently 请求的网页已永久移动到新位置。<br>
302 Found 临时性重定向。<br>
303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。<br>
304 Not Modified 自从上次请求后，请求的网页未修改过。<br>
400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>
401 Unauthorized 请求未授权。<br>
403 Forbidden 禁止访问。<br>
404 Not Found 找不到如何与 URI 相匹配的资源。<br>
500 Internal Server Error 最常见的服务器端错误。<br>
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p></blockquote> <h3 id="_6-图片懒加载"><a href="#_6-图片懒加载" class="header-anchor">#</a> 6. 图片懒加载？</h3> <blockquote><p>当页面滚动的时间被触发 -&gt; 执行加载图片操作 -&gt; 判断图片是否在可视区域内 -&gt; 在，则动态将data-src的值赋予该图片</p></blockquote> <h3 id="_7-移动端性能优化"><a href="#_7-移动端性能优化" class="header-anchor">#</a> 7. 移动端性能优化？</h3> <blockquote><ul><li>尽量使用css3动画，开启硬件加速</li> <li>适当使用touch时间代替click时间</li> <li>避免使用css3渐变阴影效果</li> <li>可以用transform: translateZ(0) 来开启硬件加速</li> <li>不滥用float。float在渲染时计算量比较大，尽量减少使用</li> <li>不滥用web字体。web字体需要下载，解析，重绘当前页面</li> <li>合理使用requestAnimationFrame动画代替setTimeout</li> <li>css中的属性（css3 transitions、css3 3D transforms、opacity、webGL、video）会触发GUP渲染，耗电</li></ul></blockquote> <h3 id="_8-tcp-传输的三次握手、四次挥手策略"><a href="#_8-tcp-传输的三次握手、四次挥手策略" class="header-anchor">#</a> 8. TCP 传输的三次握手、四次挥手策略</h3> <blockquote><ul><li><p>三次握手：</p> <p>为了准确无误地吧数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，他一定会向对方确认是否送达，握手过程中使用TCP的标志：SYN和ACK</p> <ul><li>发送端首先发送一个带SYN的标志的数据包给对方</li> <li>接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息</li> <li>最后，发送端再回传一个带ACK的标志的数据包，代表“握手”结束</li></ul></li> <li><p>如在握手过程中某个阶段莫明中断，TCP协议会再次以相同的顺序发送相同的数据包</p></li></ul> <hr> <ul><li>断开一个TCP连接需要“四次挥手”
<ul><li>第一次挥手：主动关闭方发送一个FIN，用来关注主动方到被动关闭方的数据传送，也即是主动关闭方告诫被动关闭方：我已经不会再给你发数据了（在FIN包之前发送的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据）。但是，此时主动关闭方还可以接受数据</li> <li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号收到序号 +1（与SYN相同，一个 FIN占用一个序号）</li> <li>第三次挥手：被动关闭方发送一个 FIN。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发送数据了</li> <li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li></ul></li></ul></blockquote> <h3 id="_9-http-和-https-为什么https安全"><a href="#_9-http-和-https-为什么https安全" class="header-anchor">#</a> 9. HTTP 和 HTTPS，为什么HTTPS安全？</h3> <blockquote><ul><li>HTTP协议通常承载与 TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS</li> <li>默认HTTP的端口号为80，HTTPS的端口号为443</li> <li>因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有，https之所有说比http安全，是因为他利用ssl/tls协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性</li></ul></blockquote> <h3 id="_10-axios和fetch区别对比"><a href="#_10-axios和fetch区别对比" class="header-anchor">#</a> 10. axios和fetch区别对比</h3> <p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征</p> <ul><li>从浏览器中创建 XMLHttpRequest</li> <li>支持 Promise API</li> <li>客户端支持防止CSRF</li> <li>提供了一些并发请求的接口（重要，方便了很多的操作）</li> <li>从 node.js 创建 http 请求</li> <li>拦截请求和响应</li> <li>转换请求和响应数据</li> <li>取消请求</li> <li>自动转换JSON数据</li></ul> <p><strong>fetch优势：</strong></p> <ul><li>语法简洁，更加语义化</li> <li>基于标准 Promise 实现，支持 async/await</li> <li>同构方便，使用 isomorphic-fetch</li> <li>更加底层，提供的API丰富（request, response）</li> <li>脱离了XHR，是ES规范里新的实现方式</li></ul> <p><strong>fetch存在问题</strong></p> <ul><li>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。</li> <li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li> <li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li> <li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li> <li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul> <hr> <h1 id="十二、主观题篇"><a href="#十二、主观题篇" class="header-anchor">#</a> 十二、主观题篇</h1> <h3 id="_1-你都做过什么项目呢-具体聊某一个项目中运用的技术"><a href="#_1-你都做过什么项目呢-具体聊某一个项目中运用的技术" class="header-anchor">#</a> 1. 你都做过什么项目呢？具体聊某一个项目中运用的技术.</h3> <blockquote><p>注意：用心找自己做的项目中自己感觉最拿出来手的（复杂度最高，用的技术最多的项目），描述的时候尽可能往里面添加一些技术名词<br>
布局我们用html5+css3<br>
我们会用reset.css重置浏览器的默认样式<br>
JS框架的话我们选用的是jQuery(也可能是Zepto)<br>
我们用版本控制工具git来协同开发<br>
我们会基于gulp搭建的前端自动化工程来开发（里面包含有我们的项目结构、我们需要引用的第三方库等一些信息，我们还实现了sass编译、CSS3加前缀等的自动化）<br>
我们的项目中还用到了表单验证validate插件、图片懒加载Lazyload插件</p></blockquote> <h3 id="_2-你遇到过比较难的技术问题是-你是如何解决的"><a href="#_2-你遇到过比较难的技术问题是-你是如何解决的" class="header-anchor">#</a> 2. 你遇到过比较难的技术问题是？你是如何解决的？</h3> <h3 id="_3-常使用的库有哪些-常用的前端开发工具-开发过什么应用或组件"><a href="#_3-常使用的库有哪些-常用的前端开发工具-开发过什么应用或组件" class="header-anchor">#</a> 3. 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</h3> <h3 id="_4-除了前端以外还了解什么其它技术么-你最最厉害的技能是什么"><a href="#_4-除了前端以外还了解什么其它技术么-你最最厉害的技能是什么" class="header-anchor">#</a> 4. 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</h3> <h3 id="_5-对前端开发工程师这个职位是怎么样理解的-它的前景会怎么样"><a href="#_5-对前端开发工程师这个职位是怎么样理解的-它的前景会怎么样" class="header-anchor">#</a> 5. 对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？</h3> <blockquote><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>
1、实现界面交互<br>
2、提升用户体验<br>
3、有了Node.js，前端可以实现服务端的一些事情<br>
前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，<br>
参与项目，快速高质量完成实现效果图，精确到1px；<br>
与团队成员，UI设计，产品经理的沟通；<br>
做好的页面结构，页面重构和用户体验；<br>
处理hack，兼容、写出优美的代码格式；<br>
针对服务器的优化、拥抱最新前端技术。</p></blockquote> <p>你发送数据了</p> <blockquote><ul><li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li></ul></blockquote> <h3 id="_9-http-和-https-为什么https安全-2"><a href="#_9-http-和-https-为什么https安全-2" class="header-anchor">#</a> 9. HTTP 和 HTTPS，为什么HTTPS安全？</h3> <blockquote><ul><li>HTTP协议通常承载与 TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS</li> <li>默认HTTP的端口号为80，HTTPS的端口号为443</li> <li>因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有，https之所有说比http安全，是因为他利用ssl/tls协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性</li></ul></blockquote> <h3 id="_10-axios和fetch区别对比-2"><a href="#_10-axios和fetch区别对比-2" class="header-anchor">#</a> 10. axios和fetch区别对比</h3> <p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征</p> <ul><li>从浏览器中创建 XMLHttpRequest</li> <li>支持 Promise API</li> <li>客户端支持防止CSRF</li> <li>提供了一些并发请求的接口（重要，方便了很多的操作）</li> <li>从 node.js 创建 http 请求</li> <li>拦截请求和响应</li> <li>转换请求和响应数据</li> <li>取消请求</li> <li>自动转换JSON数据</li></ul> <p><strong>fetch优势：</strong></p> <ul><li>语法简洁，更加语义化</li> <li>基于标准 Promise 实现，支持 async/await</li> <li>同构方便，使用 isomorphic-fetch</li> <li>更加底层，提供的API丰富（request, response）</li> <li>脱离了XHR，是ES规范里新的实现方式</li></ul> <p><strong>fetch存在问题</strong></p> <ul><li>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。</li> <li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li> <li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li> <li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li> <li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul> <hr> <h1 id="十三、主观题篇"><a href="#十三、主观题篇" class="header-anchor">#</a> 十三、主观题篇</h1> <h3 id="_1-你都做过什么项目呢-具体聊某一个项目中运用的技术-2"><a href="#_1-你都做过什么项目呢-具体聊某一个项目中运用的技术-2" class="header-anchor">#</a> 1. 你都做过什么项目呢？具体聊某一个项目中运用的技术.</h3> <blockquote><p>注意：用心找自己做的项目中自己感觉最拿出来手的（复杂度最高，用的技术最多的项目），描述的时候尽可能往里面添加一些技术名词<br>
布局我们用html5+css3<br>
我们会用reset.css重置浏览器的默认样式<br>
JS框架的话我们选用的是jQuery(也可能是Zepto)<br>
我们用版本控制工具git来协同开发<br>
我们会基于gulp搭建的前端自动化工程来开发（里面包含有我们的项目结构、我们需要引用的第三方库等一些信息，我们还实现了sass编译、CSS3加前缀等的自动化）<br>
我们的项目中还用到了表单验证validate插件、图片懒加载Lazyload插件</p></blockquote> <h3 id="_2-你遇到过比较难的技术问题是-你是如何解决的-2"><a href="#_2-你遇到过比较难的技术问题是-你是如何解决的-2" class="header-anchor">#</a> 2. 你遇到过比较难的技术问题是？你是如何解决的？</h3> <h3 id="_3-常使用的库有哪些-常用的前端开发工具-开发过什么应用或组件-2"><a href="#_3-常使用的库有哪些-常用的前端开发工具-开发过什么应用或组件-2" class="header-anchor">#</a> 3. 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</h3> <h3 id="_4-除了前端以外还了解什么其它技术么-你最最厉害的技能是什么-2"><a href="#_4-除了前端以外还了解什么其它技术么-你最最厉害的技能是什么-2" class="header-anchor">#</a> 4. 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</h3> <h3 id="_5-对前端开发工程师这个职位是怎么样理解的-它的前景会怎么样-2"><a href="#_5-对前端开发工程师这个职位是怎么样理解的-它的前景会怎么样-2" class="header-anchor">#</a> 5. 对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？</h3> <blockquote><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>
1、实现界面交互<br>
2、提升用户体验<br>
3、有了Node.js，前端可以实现服务端的一些事情<br>
前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，<br>
参与项目，快速高质量完成实现效果图，精确到1px；<br>
与团队成员，UI设计，产品经理的沟通；<br>
做好的页面结构，页面重构和用户体验；<br>
处理hack，兼容、写出优美的代码格式；<br>
针对服务器的优化、拥抱最新前端技术。</p></blockquote></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_1-谈谈你对mvvm开发模式的理解" class="sidebar-link reco-side-_1-谈谈你对mvvm开发模式的理解" data-v-b57cc07c>1\. 谈谈你对MVVM开发模式的理解？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_2-v-if-和-v-show-有什么区别" class="sidebar-link reco-side-_2-v-if-和-v-show-有什么区别" data-v-b57cc07c>2\. v-if 和 v-show 有什么区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_3-route-和-route和-route和router区别" class="sidebar-link reco-side-_3-route-和-route和-route和router区别" data-v-b57cc07c>3. route 和 route和 route和router区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_4-vue自定义指令" class="sidebar-link reco-side-_4-vue自定义指令" data-v-b57cc07c>4.vue自定义指令</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_5-vue项目优化" class="sidebar-link reco-side-_5-vue项目优化" data-v-b57cc07c>5.vue项目优化</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_6-vue模板如何编译" class="sidebar-link reco-side-_6-vue模板如何编译" data-v-b57cc07c>6.vue模板如何编译</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_7-vue2响应式原理" class="sidebar-link reco-side-_7-vue2响应式原理" data-v-b57cc07c>7.vue2响应式原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_8-vue3响应式原理" class="sidebar-link reco-side-_8-vue3响应式原理" data-v-b57cc07c>8.vue3响应式原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_9-刷新浏览器后-vuex的数据是否存在-如何解决" class="sidebar-link reco-side-_9-刷新浏览器后-vuex的数据是否存在-如何解决" data-v-b57cc07c>9.刷新浏览器后，Vuex的数据是否存在？如何解决？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_10-vue和react共同点-区别" class="sidebar-link reco-side-_10-vue和react共同点-区别" data-v-b57cc07c>10.vue和react共同点？区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_11-vue双向数据绑定原理" class="sidebar-link reco-side-_11-vue双向数据绑定原理" data-v-b57cc07c>11.vue双向数据绑定原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_12-computed和watch区别" class="sidebar-link reco-side-_12-computed和watch区别" data-v-b57cc07c>12.computed和watch区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_13-vuex" class="sidebar-link reco-side-_13-vuex" data-v-b57cc07c>13.Vuex</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_14-vuex辅助函数" class="sidebar-link reco-side-_14-vuex辅助函数" data-v-b57cc07c>14.vuex辅助函数</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_15-vuex模块化使用" class="sidebar-link reco-side-_15-vuex模块化使用" data-v-b57cc07c>15.vuex模块化使用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_16-vue中mixin" class="sidebar-link reco-side-_16-vue中mixin" data-v-b57cc07c>16.vue中mixin</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_17-vue中给对象添加新属性时-界面不刷新怎么办" class="sidebar-link reco-side-_17-vue中给对象添加新属性时-界面不刷新怎么办" data-v-b57cc07c>17.Vue中给对象添加新属性时，界面不刷新怎么办?</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_18-vue组件通讯方式" class="sidebar-link reco-side-_18-vue组件通讯方式" data-v-b57cc07c>18.vue组件通讯方式</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_19-vue3setup的父传子怎么去写" class="sidebar-link reco-side-_19-vue3setup的父传子怎么去写" data-v-b57cc07c>19.vue3setup的父传子怎么去写？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_20-setup可不可以直接写async和await" class="sidebar-link reco-side-_20-setup可不可以直接写async和await" data-v-b57cc07c>20.setup可不可以直接写async和await？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_21-vue生命周期" class="sidebar-link reco-side-_21-vue生命周期" data-v-b57cc07c>21.vue生命周期</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_22-说说-vue-中-css-scoped-的原理" class="sidebar-link reco-side-_22-说说-vue-中-css-scoped-的原理" data-v-b57cc07c>22.说说 Vue 中 CSS scoped 的原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_23-nexttick原理" class="sidebar-link reco-side-_23-nexttick原理" data-v-b57cc07c>23.$nextTick原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_24-data是函数不是对象" class="sidebar-link reco-side-_24-data是函数不是对象" data-v-b57cc07c>24.data是函数不是对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_25-路由守卫" class="sidebar-link reco-side-_25-路由守卫" data-v-b57cc07c>25.路由守卫</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_26-vue设置全局变量" class="sidebar-link reco-side-_26-vue设置全局变量" data-v-b57cc07c>26.vue设置全局变量</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_27-vue中keep-alive" class="sidebar-link reco-side-_27-vue中keep-alive" data-v-b57cc07c>27.vue中keep-alive</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_28-vue插槽" class="sidebar-link reco-side-_28-vue插槽" data-v-b57cc07c>28.vue插槽</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_29-vue2和vue3区别" class="sidebar-link reco-side-_29-vue2和vue3区别" data-v-b57cc07c>29.vue2和vue3区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_30-vue3-0-所采用的-composition-api-组合式-与-vue2-x-使用的-options-api-选项式-有什么不同" class="sidebar-link reco-side-_30-vue3-0-所采用的-composition-api-组合式-与-vue2-x-使用的-options-api-选项式-有什么不同" data-v-b57cc07c>30.Vue3.0 所采用的 Composition Api (组合式)与 Vue2.x 使用的 Options Api(选项式) 有什么不同？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_31-vue3中hook" class="sidebar-link reco-side-_31-vue3中hook" data-v-b57cc07c>31.vue3中hook</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_32-vue组件和插件的区别" class="sidebar-link reco-side-_32-vue组件和插件的区别" data-v-b57cc07c>32.vue组件和插件的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_33-vue修饰符" class="sidebar-link reco-side-_33-vue修饰符" data-v-b57cc07c>33.vue修饰符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_34-vue路由中-history和hash两种模式有什么区别" class="sidebar-link reco-side-_34-vue路由中-history和hash两种模式有什么区别" data-v-b57cc07c>34.Vue路由中，history和hash两种模式有什么区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_35-params和query区别" class="sidebar-link reco-side-_35-params和query区别" data-v-b57cc07c>35.params和query区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_36-vue2中assets和vue3中public区别" class="sidebar-link reco-side-_36-vue2中assets和vue3中public区别" data-v-b57cc07c>36.vue2中assets和vue3中public区别 ？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_37-单页应用如何提高加载速度" class="sidebar-link reco-side-_37-单页应用如何提高加载速度" data-v-b57cc07c>37.单页应用如何提高加载速度？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_38-vue父组件调用子组件的方法" class="sidebar-link reco-side-_38-vue父组件调用子组件的方法" data-v-b57cc07c>38.Vue父组件调用子组件的方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_39-vue3中dom获取-ref在组件上使用" class="sidebar-link reco-side-_39-vue3中dom获取-ref在组件上使用" data-v-b57cc07c>39.vue3中dom获取，ref在组件上使用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_40-渐进式框架理解" class="sidebar-link reco-side-_40-渐进式框架理解" data-v-b57cc07c>40.渐进式框架理解</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_41-页面初始化闪烁" class="sidebar-link reco-side-_41-页面初始化闪烁" data-v-b57cc07c>41.页面初始化闪烁</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_42-vue属性名和method名称一致出现什么问题" class="sidebar-link reco-side-_42-vue属性名和method名称一致出现什么问题" data-v-b57cc07c>42.vue属性名和method名称一致出现什么问题</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_43-class和style如何动态绑定" class="sidebar-link reco-side-_43-class和style如何动态绑定" data-v-b57cc07c>43.class和style如何动态绑定</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_44-vue遇到的坑" class="sidebar-link reco-side-_44-vue遇到的坑" data-v-b57cc07c>44.vue遇到的坑</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_45-v-if和v-for-优先级" class="sidebar-link reco-side-_45-v-if和v-for-优先级" data-v-b57cc07c>45.v-if和v-for 优先级</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_46-vue核心原理" class="sidebar-link reco-side-_46-vue核心原理" data-v-b57cc07c>46.vue核心原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_47-vue自带动画组件-transition" class="sidebar-link reco-side-_47-vue自带动画组件-transition" data-v-b57cc07c>47.vue自带动画组件， transition</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_48-vue-loader工作原理" class="sidebar-link reco-side-_48-vue-loader工作原理" data-v-b57cc07c>48.vue-loader工作原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_49-vue的diff算法" class="sidebar-link reco-side-_49-vue的diff算法" data-v-b57cc07c>49.vue的diff算法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_50-vue和jquery区别" class="sidebar-link reco-side-_50-vue和jquery区别" data-v-b57cc07c>50.vue和jquery区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_51-说说你对-spa-单页面的理解-它的优缺点分别是什么" class="sidebar-link reco-side-_51-说说你对-spa-单页面的理解-它的优缺点分别是什么" data-v-b57cc07c>51.说说你对 SPA 单页面的理解，它的优缺点分别是什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_52-怎样理解-vue-的单向数据流" class="sidebar-link reco-side-_52-怎样理解-vue-的单向数据流" data-v-b57cc07c>52\. 怎样理解 Vue 的单向数据流？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_53-父组件可以监听到子组件的生命周期吗" class="sidebar-link reco-side-_53-父组件可以监听到子组件的生命周期吗" data-v-b57cc07c>53\. 父组件可以监听到子组件的生命周期吗？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_54-vue3-0-性能提升主要是通过哪几方面体现的" class="sidebar-link reco-side-_54-vue3-0-性能提升主要是通过哪几方面体现的" data-v-b57cc07c>54.Vue3.0 性能提升主要是通过哪几方面体现的</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_55-什么是-mvvm-比之-mvc-有什么区别-什么又是-mvp" class="sidebar-link reco-side-_55-什么是-mvvm-比之-mvc-有什么区别-什么又是-mvp" data-v-b57cc07c>55.什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_56-vue中hook和react中hook区别" class="sidebar-link reco-side-_56-vue中hook和react中hook区别" data-v-b57cc07c>56.vue中hook和react中hook区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_57-redux和vuex的区别" class="sidebar-link reco-side-_57-redux和vuex的区别" data-v-b57cc07c>57.Redux和Vuex的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_58-vue服务端渲染-ssr-解决了哪些问题" class="sidebar-link reco-side-_58-vue服务端渲染-ssr-解决了哪些问题" data-v-b57cc07c>58.vue服务端渲染(SSR),解决了哪些问题？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_59-vue-3-0中treeshaking特性是什么-并举例进行说明" class="sidebar-link reco-side-_59-vue-3-0中treeshaking特性是什么-并举例进行说明" data-v-b57cc07c>59.Vue 3.0中Treeshaking特性是什么，并举例进行说明？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_60-虚拟-dom-的优缺点" class="sidebar-link reco-side-_60-虚拟-dom-的优缺点" data-v-b57cc07c>60\. 虚拟 DOM 的优缺点？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_61-虚拟-dom-实现原理" class="sidebar-link reco-side-_61-虚拟-dom-实现原理" data-v-b57cc07c>61. 虚拟 DOM 实现原理？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_62-vue-中的-key-有什么作用" class="sidebar-link reco-side-_62-vue-中的-key-有什么作用" data-v-b57cc07c>62\. Vue 中的 key 有什么作用？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_62-1-object-defineproperty怎么用-三个参数-有什么作用啊" class="sidebar-link reco-side-_62-1-object-defineproperty怎么用-三个参数-有什么作用啊" data-v-b57cc07c>62.1 Object.defineProperty怎么用， 三个参数？，有什么作用啊？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_63-reactive与ref的区别" class="sidebar-link reco-side-_63-reactive与ref的区别" data-v-b57cc07c>63.reactive与ref的区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_64-v-on可以监听多个方法吗" class="sidebar-link reco-side-_64-v-on可以监听多个方法吗" data-v-b57cc07c>64.v-on可以监听多个方法吗？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_65-vue3中如何获取refs-dom对象的方式-vue2中如何使用" class="sidebar-link reco-side-_65-vue3中如何获取refs-dom对象的方式-vue2中如何使用" data-v-b57cc07c>65.vue3中如何获取refs，dom对象的方式？vue2中如何使用？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_66-shallowreactive和shallowref的区别" class="sidebar-link reco-side-_66-shallowreactive和shallowref的区别" data-v-b57cc07c>66.shallowReactive和shallowRef的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_67-provide与inject如何使用" class="sidebar-link reco-side-_67-provide与inject如何使用" data-v-b57cc07c>67.provide与inject如何使用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_68-toraw-与-markraw是什么作用" class="sidebar-link reco-side-_68-toraw-与-markraw是什么作用" data-v-b57cc07c>68.toRaw 与 markRaw是什么作用？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_69-readonly和shallowreadonly理解" class="sidebar-link reco-side-_69-readonly和shallowreadonly理解" data-v-b57cc07c>69.Readonly和shallowReadonly理解</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_70-toref和torefs区别" class="sidebar-link reco-side-_70-toref和torefs区别" data-v-b57cc07c>70.toref和torefs区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_71-学习-eventbus" class="sidebar-link reco-side-_71-学习-eventbus" data-v-b57cc07c>71.学习 EventBus</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_72-vue2过滤器-vue3取消" class="sidebar-link reco-side-_72-vue2过滤器-vue3取消" data-v-b57cc07c>72.vue2过滤器(vue3取消)</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_73-vue可以通过计算属性监听计算属性吗" class="sidebar-link reco-side-_73-vue可以通过计算属性监听计算属性吗" data-v-b57cc07c>73\. vue可以通过计算属性监听计算属性吗</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_1-typescript基本数据类型" class="sidebar-link reco-side-_1-typescript基本数据类型" data-v-b57cc07c>1.TypeScript基本数据类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_2-void和undefined" class="sidebar-link reco-side-_2-void和undefined" data-v-b57cc07c>2.void和undefined</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_3-typescript类修饰符" class="sidebar-link reco-side-_3-typescript类修饰符" data-v-b57cc07c>3.TypeScript类修饰符</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_4-如何定义一个数组-它的元素可能是字符串类型-也可能是数值类型" class="sidebar-link reco-side-_4-如何定义一个数组-它的元素可能是字符串类型-也可能是数值类型" data-v-b57cc07c>4.如何定义一个数组，它的元素可能是字符串类型，也可能是数值类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_5-typescript接口" class="sidebar-link reco-side-_5-typescript接口" data-v-b57cc07c>5.TypeScript接口</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_6-typescript对象和typescript接口的区别" class="sidebar-link reco-side-_6-typescript对象和typescript接口的区别" data-v-b57cc07c>6.TypeScript对象和TypeScript接口的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_7-typescript类型别名" class="sidebar-link reco-side-_7-typescript类型别名" data-v-b57cc07c>7.TypeScript类型别名</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_8-typescript字面量类型" class="sidebar-link reco-side-_8-typescript字面量类型" data-v-b57cc07c>8.TypeScript字面量类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_9-typescript类型符号" class="sidebar-link reco-side-_9-typescript类型符号" data-v-b57cc07c>9.TypeScript类型符号</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_10-typescript交叉类型" class="sidebar-link reco-side-_10-typescript交叉类型" data-v-b57cc07c>10.TypeScript交叉类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_11-泛型对象" class="sidebar-link reco-side-_11-泛型对象" data-v-b57cc07c>11.泛型对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_12-类型断言" class="sidebar-link reco-side-_12-类型断言" data-v-b57cc07c>12.类型断言</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_13-unknown-类型" class="sidebar-link reco-side-_13-unknown-类型" data-v-b57cc07c>13. unknown 类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_14-函数重载" class="sidebar-link reco-side-_14-函数重载" data-v-b57cc07c>14.函数重载</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_15-抽象类" class="sidebar-link reco-side-_15-抽象类" data-v-b57cc07c>15.抽象类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_16-类型守卫-typeof-以及-instanceof" class="sidebar-link reco-side-_16-类型守卫-typeof-以及-instanceof" data-v-b57cc07c>16.类型守卫，typeof 以及 instanceof</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_17-typescript-编译上下文" class="sidebar-link reco-side-_17-typescript-编译上下文" data-v-b57cc07c>17.TypeScript 编译上下文</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_18-tsconfig-json" class="sidebar-link reco-side-_18-tsconfig-json" data-v-b57cc07c>18.tsconfig.json</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_19-typescript-和javascript区别" class="sidebar-link reco-side-_19-typescript-和javascript区别" data-v-b57cc07c>19.TypeScript 和JavaScript区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_1-react理解" class="sidebar-link reco-side-_1-react理解" data-v-b57cc07c>1.react理解</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_2-react-router-里的-标签和-标签有什么区别" class="sidebar-link reco-side-_2-react-router-里的-标签和-标签有什么区别" data-v-b57cc07c>2.react-router 里的 标签和 标签有什么区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_3-react-jsx转换成真实dom过程" class="sidebar-link reco-side-_3-react-jsx转换成真实dom过程" data-v-b57cc07c>3.React Jsx转换成真实DOM过程？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_4-react-router的理解-原理-常用的router组件有哪些" class="sidebar-link reco-side-_4-react-router的理解-原理-常用的router组件有哪些" data-v-b57cc07c>4.React Router的理解，原理？常用的Router组件有哪些？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_5-react生命周期" class="sidebar-link reco-side-_5-react生命周期" data-v-b57cc07c>5.react生命周期</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_6-react新生命周期取代了哪些-为什么" class="sidebar-link reco-side-_6-react新生命周期取代了哪些-为什么" data-v-b57cc07c>6.react新生命周期取代了哪些？为什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_7-fiber架构的理解-解决了什么问题" class="sidebar-link reco-side-_7-fiber架构的理解-解决了什么问题" data-v-b57cc07c>7.Fiber架构的理解？解决了什么问题？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_8-react有状态组件和无状态组件的理解及使用场景-、" class="sidebar-link reco-side-_8-react有状态组件和无状态组件的理解及使用场景-、" data-v-b57cc07c>8.react有状态组件和无状态组件的理解及使用场景？、</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_9-react-的事件合成" class="sidebar-link reco-side-_9-react-的事件合成" data-v-b57cc07c>9. React 的事件合成？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_10-react组件之间如何通信" class="sidebar-link reco-side-_10-react组件之间如何通信" data-v-b57cc07c>10.React组件之间如何通信？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_11-react服务端渲染怎么做-原理是什么" class="sidebar-link reco-side-_11-react服务端渲染怎么做-原理是什么" data-v-b57cc07c>11.React服务端渲染怎么做？原理是什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_12-使用-react-hooks-怎么实现类里面的所有生命周期" class="sidebar-link reco-side-_12-使用-react-hooks-怎么实现类里面的所有生命周期" data-v-b57cc07c>12.使用 React hooks 怎么实现类里面的所有生命周期？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_13-react事件和原生事件的执行顺序" class="sidebar-link reco-side-_13-react事件和原生事件的执行顺序" data-v-b57cc07c>13.React事件和原生事件的执行顺序</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_14-为什么react元素有一个-type属性" class="sidebar-link reco-side-_14-为什么react元素有一个-type属性" data-v-b57cc07c>14.为什么react元素有一个$$type属性？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_15-setstate-是同步-还是异步的" class="sidebar-link reco-side-_15-setstate-是同步-还是异步的" data-v-b57cc07c>15.setState 是同步，还是异步的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_16-如何让-useeffect-支持-async-await" class="sidebar-link reco-side-_16-如何让-useeffect-支持-async-await" data-v-b57cc07c>16.如何让 useEffect 支持 async/await？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_17-react-中可以做哪些性能优化" class="sidebar-link reco-side-_17-react-中可以做哪些性能优化" data-v-b57cc07c>17. React 中可以做哪些性能优化？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_18-react-和-vue-有什么区别" class="sidebar-link reco-side-_18-react-和-vue-有什么区别" data-v-b57cc07c>18.react 和 vue 有什么区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_19-react-render方法的原理-在什么时候会触发" class="sidebar-link reco-side-_19-react-render方法的原理-在什么时候会触发" data-v-b57cc07c>19.React render方法的原理，在什么时候会触发？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_20-react-hooks-在使用上有哪些限制" class="sidebar-link reco-side-_20-react-hooks-在使用上有哪些限制" data-v-b57cc07c>20.React Hooks 在使用上有哪些限制？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_21-react-hooks概述及常用的hooks介绍" class="sidebar-link reco-side-_21-react-hooks概述及常用的hooks介绍" data-v-b57cc07c>21.React Hooks概述及常用的Hooks介绍？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_22-说说react生命周期中有哪些坑-如何避免" class="sidebar-link reco-side-_22-说说react生命周期中有哪些坑-如何避免" data-v-b57cc07c>22.说说React生命周期中有哪些坑？如何避免？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_23-说说real-diff算法是怎么运作的" class="sidebar-link reco-side-_23-说说real-diff算法是怎么运作的" data-v-b57cc07c>23.说说Real diff算法是怎么运作的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_24-调和阶段setstate干了什么" class="sidebar-link reco-side-_24-调和阶段setstate干了什么" data-v-b57cc07c>24.调和阶段setState干了什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_25-使用-redux-有哪些原则" class="sidebar-link reco-side-_25-使用-redux-有哪些原则" data-v-b57cc07c>25.使用 redux 有哪些原则？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_26-说说redux的实现原理是什么-写出核心代码" class="sidebar-link reco-side-_26-说说redux的实现原理是什么-写出核心代码" data-v-b57cc07c>26.说说redux的实现原理是什么，写出核心代码？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_27-对redux中间件的理解-原理-常用中间件有哪些" class="sidebar-link reco-side-_27-对redux中间件的理解-原理-常用中间件有哪些" data-v-b57cc07c>27.对Redux中间件的理解？原理？常用中间件有哪些？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_28-redux-和-vuex-有什么区别-它们有什么共同思想吗" class="sidebar-link reco-side-_28-redux-和-vuex-有什么区别-它们有什么共同思想吗" data-v-b57cc07c>28.Redux 和 Vuex 有什么区别，它们有什么共同思想吗？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_29-props和state相同点和不同点" class="sidebar-link reco-side-_29-props和state相同点和不同点" data-v-b57cc07c>29.props和state相同点和不同点？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_30-shouldcomponentupdate有什么作用" class="sidebar-link reco-side-_30-shouldcomponentupdate有什么作用" data-v-b57cc07c>30.shouldComponentUpdate有什么作用？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_31-react的props-children使用map函数来遍历会收到异常显示-为什么-应该-如何遍历" class="sidebar-link reco-side-_31-react的props-children使用map函数来遍历会收到异常显示-为什么-应该-如何遍历" data-v-b57cc07c>31.React的props.children使用map函数来遍历会收到异常显示，为什么？应该 如何遍历</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_32-谈谈你对immutable-js的理解" class="sidebar-link reco-side-_32-谈谈你对immutable-js的理解" data-v-b57cc07c>32.谈谈你对immutable.js的理解？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_33-redux原理、工作流程及其应用-三大原则" class="sidebar-link reco-side-_33-redux原理、工作流程及其应用-三大原则" data-v-b57cc07c>33.redux原理、工作流程及其应用，三大原则</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_34-react-redux原理-工作流程" class="sidebar-link reco-side-_34-react-redux原理-工作流程" data-v-b57cc07c>34.react-redux原理，工作流程</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_35-react组件通讯的context" class="sidebar-link reco-side-_35-react组件通讯的context" data-v-b57cc07c>35.react组件通讯的context</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_36-react-redux中-provider-组件实现原理" class="sidebar-link reco-side-_36-react-redux中-provider-组件实现原理" data-v-b57cc07c>36.react-redux中 Provider 组件实现原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_37-react-redux中connect原理" class="sidebar-link reco-side-_37-react-redux中connect原理" data-v-b57cc07c>37.react-redux中Connect原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_38-react-toolkit" class="sidebar-link reco-side-_38-react-toolkit" data-v-b57cc07c>38.react-toolkit</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_39-react-memo-和-usememo-的用法是什么-有哪些区别" class="sidebar-link reco-side-_39-react-memo-和-usememo-的用法是什么-有哪些区别" data-v-b57cc07c>39.React.memo() 和 useMemo() 的用法是什么，有哪些区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_40-usecallback-usememo区别" class="sidebar-link reco-side-_40-usecallback-usememo区别" data-v-b57cc07c>40.usecallback，usememo区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_41-react使用ref" class="sidebar-link reco-side-_41-react使用ref" data-v-b57cc07c>41.react使用ref</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_42-为什么循环和判断不能使用hooks" class="sidebar-link reco-side-_42-为什么循环和判断不能使用hooks" data-v-b57cc07c>42.为什么循环和判断不能使用hooks</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_43-react实现过度动画" class="sidebar-link reco-side-_43-react实现过度动画" data-v-b57cc07c>43.React实现过度动画</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_44-react懒加载实现原理" class="sidebar-link reco-side-_44-react懒加载实现原理" data-v-b57cc07c>44. react懒加载实现原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_45-immutable" class="sidebar-link reco-side-_45-immutable" data-v-b57cc07c>45.immutable</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_46-usestate为什么返回数组而不是对象" class="sidebar-link reco-side-_46-usestate为什么返回数组而不是对象" data-v-b57cc07c>46.useState为什么返回数组而不是对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_47-类组件为什么不能使用hooks" class="sidebar-link reco-side-_47-类组件为什么不能使用hooks" data-v-b57cc07c>47.类组件为什么不能使用hooks</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_48-redux-thunk和redux-saga区别" class="sidebar-link reco-side-_48-redux-thunk和redux-saga区别" data-v-b57cc07c>48.redux-thunk和redux-saga区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_49-react合成事件使用原因-原理" class="sidebar-link reco-side-_49-react合成事件使用原因-原理" data-v-b57cc07c>49.react合成事件使用原因，原理</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_50-react事件代理机制" class="sidebar-link reco-side-_50-react事件代理机制" data-v-b57cc07c>50.React事件代理机制</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_51-react事件和原生事件的执行顺序" class="sidebar-link reco-side-_51-react事件和原生事件的执行顺序" data-v-b57cc07c>51.React事件和原生事件的执行顺序</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_52-jsx转换真实dom流程" class="sidebar-link reco-side-_52-jsx转换真实dom流程" data-v-b57cc07c>52.jsx转换真实dom流程</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_53-什么是jsx" class="sidebar-link reco-side-_53-什么是jsx" data-v-b57cc07c>53.什么是JSX？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_1-请谈谈wxml与标准的html的异同" class="sidebar-link reco-side-_1-请谈谈wxml与标准的html的异同" data-v-b57cc07c>1. 请谈谈WXML与标准的html的异同？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_2-请谈谈wxss和css的异同" class="sidebar-link reco-side-_2-请谈谈wxss和css的异同" data-v-b57cc07c>2. 请谈谈WXSS和CSS的异同？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_3-请谈谈微信小程序主要目录和文件的作用" class="sidebar-link reco-side-_3-请谈谈微信小程序主要目录和文件的作用" data-v-b57cc07c>3.请谈谈微信小程序主要目录和文件的作用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_4-请谈谈小程序的双向绑定和vue的异同" class="sidebar-link reco-side-_4-请谈谈小程序的双向绑定和vue的异同" data-v-b57cc07c>4.请谈谈小程序的双向绑定和vue的异同</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_5-简单描述下微信小程序的相关文件类型" class="sidebar-link reco-side-_5-简单描述下微信小程序的相关文件类型" data-v-b57cc07c>5.简单描述下微信小程序的相关文件类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_6-微信小程序有哪些传值-传递数据-方法" class="sidebar-link reco-side-_6-微信小程序有哪些传值-传递数据-方法" data-v-b57cc07c>6.微信小程序有哪些传值(传递数据)方法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_7-bindtap和catchtap区别" class="sidebar-link reco-side-_7-bindtap和catchtap区别" data-v-b57cc07c>7.Bindtap和catchtap区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_8-wx-navigateto-wx-redirectto-wx-switchtab-wx-navigateback-wx-relaunch-的区别" class="sidebar-link reco-side-_8-wx-navigateto-wx-redirectto-wx-switchtab-wx-navigateback-wx-relaunch-的区别" data-v-b57cc07c>8.wx.navigateTo(),wx.redirectTo(),wx.switchTab(),wx.navigateBack(),wx.reLaunch()的区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_9-微信小程序和h5区别" class="sidebar-link reco-side-_9-微信小程序和h5区别" data-v-b57cc07c>9.微信小程序和h5区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_10-小程序和vue写法区别" class="sidebar-link reco-side-_10-小程序和vue写法区别" data-v-b57cc07c>10.小程序和vue写法区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_11-rpx的理解" class="sidebar-link reco-side-_11-rpx的理解" data-v-b57cc07c>11.Rpx的理解：</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_12-微信小程序可以做dom操作吗" class="sidebar-link reco-side-_12-微信小程序可以做dom操作吗" data-v-b57cc07c>12.微信小程序可以做dom操作吗？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_13-小程序和vue区别" class="sidebar-link reco-side-_13-小程序和vue区别" data-v-b57cc07c>13.小程序和vue区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_14-小程序自定义tabbar理解" class="sidebar-link reco-side-_14-小程序自定义tabbar理解" data-v-b57cc07c>14.小程序自定义tabbar理解？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_15-微信小程序如何设置缓存" class="sidebar-link reco-side-_15-微信小程序如何设置缓存" data-v-b57cc07c>15.微信小程序如何设置缓存？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_16-微信小程序如何进行网络请求" class="sidebar-link reco-side-_16-微信小程序如何进行网络请求" data-v-b57cc07c>16. 微信小程序如何进行网络请求？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_17-小程序生命周期分为三个部分" class="sidebar-link reco-side-_17-小程序生命周期分为三个部分" data-v-b57cc07c>17. 小程序生命周期分为三个部分</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_18-微信小程序如何做模块化" class="sidebar-link reco-side-_18-微信小程序如何做模块化" data-v-b57cc07c>18. 微信小程序如何做模块化？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_19-微信所有api都放在哪里-简单介绍几个" class="sidebar-link reco-side-_19-微信所有api都放在哪里-简单介绍几个" data-v-b57cc07c>19. 微信所有api都放在哪里，简单介绍几个</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_20-微信小程序应用和页面生命周期触发顺序" class="sidebar-link reco-side-_20-微信小程序应用和页面生命周期触发顺序" data-v-b57cc07c>20. 微信小程序应用和页面生命周期触发顺序？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_21-微信小程序自定义组件使用" class="sidebar-link reco-side-_21-微信小程序自定义组件使用" data-v-b57cc07c>21. 微信小程序自定义组件使用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_22-微信小程序事件通道使用" class="sidebar-link reco-side-_22-微信小程序事件通道使用" data-v-b57cc07c>22. 微信小程序事件通道使用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_23-小程序如何使用vant组件库" class="sidebar-link reco-side-_23-小程序如何使用vant组件库" data-v-b57cc07c>23. 小程序如何使用vant组件库</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_24-微信小程序父子传递" class="sidebar-link reco-side-_24-微信小程序父子传递" data-v-b57cc07c>24. 微信小程序父子传递</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_25-小程序授权登录" class="sidebar-link reco-side-_25-小程序授权登录" data-v-b57cc07c>25. 小程序授权登录</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_26-web-view" class="sidebar-link reco-side-_26-web-view" data-v-b57cc07c>26. web-view</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_1-谈谈你对webpack的理解-webpack是什么" class="sidebar-link reco-side-_1-谈谈你对webpack的理解-webpack是什么" data-v-b57cc07c>1. 谈谈你对Webpack的理解（Webpack是什么？）</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_2-webpack的打包过程-打包原理-构建流程" class="sidebar-link reco-side-_2-webpack的打包过程-打包原理-构建流程" data-v-b57cc07c>2. Webpack的打包过程/打包原理/构建流程？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_3-loader的作用" class="sidebar-link reco-side-_3-loader的作用" data-v-b57cc07c>3. loader的作用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_4-有哪些常见的loader-他们是解决什么问题的" class="sidebar-link reco-side-_4-有哪些常见的loader-他们是解决什么问题的" data-v-b57cc07c>4. 有哪些常见的Loader？他们是解决什么问题的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_5-plugin的作用" class="sidebar-link reco-side-_5-plugin的作用" data-v-b57cc07c>5. plugin的作用</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_6-有哪些常见的plugin-他们是解决什么问题的" class="sidebar-link reco-side-_6-有哪些常见的plugin-他们是解决什么问题的" data-v-b57cc07c>6. 有哪些常见的Plugin？他们是解决什么问题的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_7-webpack中loader和plugin的区别" class="sidebar-link reco-side-_7-webpack中loader和plugin的区别" data-v-b57cc07c>7. Webpack中Loader和Plugin的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_8-webpack的热更新是如何做到的-说明其原理" class="sidebar-link reco-side-_8-webpack的热更新是如何做到的-说明其原理" data-v-b57cc07c>8. webpack的热更新是如何做到的？说明其原理？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_9-如何解决循环依赖问题" class="sidebar-link reco-side-_9-如何解决循环依赖问题" data-v-b57cc07c>9. 如何解决循环依赖问题</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_10-如何提高webpack构建速度" class="sidebar-link reco-side-_10-如何提高webpack构建速度" data-v-b57cc07c>10. 如何提高Webpack构建速度</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_1-浏览器缓存优化" class="sidebar-link reco-side-_1-浏览器缓存优化" data-v-b57cc07c>1. 浏览器缓存优化</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_2-渲染层面性能优化" class="sidebar-link reco-side-_2-渲染层面性能优化" data-v-b57cc07c>2. 渲染层面性能优化</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_3-性能优化六大指标" class="sidebar-link reco-side-_3-性能优化六大指标" data-v-b57cc07c>3. 性能优化六大指标</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_1-常见的浏览器内核有哪些" class="sidebar-link reco-side-_1-常见的浏览器内核有哪些" data-v-b57cc07c>1. 常见的浏览器内核有哪些？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_2-网页前端性能优化的方式有哪些" class="sidebar-link reco-side-_2-网页前端性能优化的方式有哪些" data-v-b57cc07c>2. 网页前端性能优化的方式有哪些？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_3-网页从输入网址到渲染完成经历了哪些过程" class="sidebar-link reco-side-_3-网页从输入网址到渲染完成经历了哪些过程" data-v-b57cc07c>3. 网页从输入网址到渲染完成经历了哪些过程？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_4-线程与进程的区别" class="sidebar-link reco-side-_4-线程与进程的区别" data-v-b57cc07c>4. 线程与进程的区别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_5-http常见的状态码" class="sidebar-link reco-side-_5-http常见的状态码" data-v-b57cc07c>5. HTTP常见的状态码？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_6-图片懒加载" class="sidebar-link reco-side-_6-图片懒加载" data-v-b57cc07c>6. 图片懒加载？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_7-移动端性能优化" class="sidebar-link reco-side-_7-移动端性能优化" data-v-b57cc07c>7. 移动端性能优化？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_8-tcp-传输的三次握手、四次挥手策略" class="sidebar-link reco-side-_8-tcp-传输的三次握手、四次挥手策略" data-v-b57cc07c>8. TCP 传输的三次握手、四次挥手策略</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_9-http-和-https-为什么https安全" class="sidebar-link reco-side-_9-http-和-https-为什么https安全" data-v-b57cc07c>9. HTTP 和 HTTPS，为什么HTTPS安全？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_10-axios和fetch区别对比" class="sidebar-link reco-side-_10-axios和fetch区别对比" data-v-b57cc07c>10. axios和fetch区别对比</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_1-你都做过什么项目呢-具体聊某一个项目中运用的技术" class="sidebar-link reco-side-_1-你都做过什么项目呢-具体聊某一个项目中运用的技术" data-v-b57cc07c>1. 你都做过什么项目呢？具体聊某一个项目中运用的技术.</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_2-你遇到过比较难的技术问题是-你是如何解决的" class="sidebar-link reco-side-_2-你遇到过比较难的技术问题是-你是如何解决的" data-v-b57cc07c>2. 你遇到过比较难的技术问题是？你是如何解决的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_3-常使用的库有哪些-常用的前端开发工具-开发过什么应用或组件" class="sidebar-link reco-side-_3-常使用的库有哪些-常用的前端开发工具-开发过什么应用或组件" data-v-b57cc07c>3. 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_4-除了前端以外还了解什么其它技术么-你最最厉害的技能是什么" class="sidebar-link reco-side-_4-除了前端以外还了解什么其它技术么-你最最厉害的技能是什么" data-v-b57cc07c>4. 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_5-对前端开发工程师这个职位是怎么样理解的-它的前景会怎么样" class="sidebar-link reco-side-_5-对前端开发工程师这个职位是怎么样理解的-它的前景会怎么样" data-v-b57cc07c>5. 对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_9-http-和-https-为什么https安全-2" class="sidebar-link reco-side-_9-http-和-https-为什么https安全-2" data-v-b57cc07c>9. HTTP 和 HTTPS，为什么HTTPS安全？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_10-axios和fetch区别对比-2" class="sidebar-link reco-side-_10-axios和fetch区别对比-2" data-v-b57cc07c>10. axios和fetch区别对比</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_1-你都做过什么项目呢-具体聊某一个项目中运用的技术-2" class="sidebar-link reco-side-_1-你都做过什么项目呢-具体聊某一个项目中运用的技术-2" data-v-b57cc07c>1. 你都做过什么项目呢？具体聊某一个项目中运用的技术.</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_2-你遇到过比较难的技术问题是-你是如何解决的-2" class="sidebar-link reco-side-_2-你遇到过比较难的技术问题是-你是如何解决的-2" data-v-b57cc07c>2. 你遇到过比较难的技术问题是？你是如何解决的？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_3-常使用的库有哪些-常用的前端开发工具-开发过什么应用或组件-2" class="sidebar-link reco-side-_3-常使用的库有哪些-常用的前端开发工具-开发过什么应用或组件-2" data-v-b57cc07c>3. 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_4-除了前端以外还了解什么其它技术么-你最最厉害的技能是什么-2" class="sidebar-link reco-side-_4-除了前端以外还了解什么其它技术么-你最最厉害的技能是什么-2" data-v-b57cc07c>4. 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%9802/test.html#_5-对前端开发工程师这个职位是怎么样理解的-它的前景会怎么样-2" class="sidebar-link reco-side-_5-对前端开发工程师这个职位是怎么样理解的-它的前景会怎么样-2" data-v-b57cc07c>5. 对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.31276dfc.js" defer></script><script src="/assets/js/3.a0fff070.js" defer></script><script src="/assets/js/1.381cc6bf.js" defer></script><script src="/assets/js/4.36f6488d.js" defer></script>
  </body>
</html>
